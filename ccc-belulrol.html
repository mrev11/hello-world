<html>
<head>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META NAME="Keywords" CONTENT="Clipper,compiler,object,oriented,multi,threaded,computer,network,program,develop,script,Java,terminal,database,learn,hungarian,language,school,courses,lessons,Budapest">
<META NAME="Description" CONTENT="Clipper to C++ Compiler (CCC) for UNIX and Windows, object oriented, multi threaded">
<META NAME="Author" CONTENT="Matyas Vermes">
<META NAME="Language" CONTENT="Hungarian">

<STYLE>
    body {
        font-family: Arial, Helvetica, sans-serif ;
        background:white
        color:black; 
    }
    pre {
        background: #eeeeff;
    }
    table {
        background: #eeeedd;
    }
    tt {
        color: #602000;
    }
</STYLE>                     

</head>
<body>



 
 

            <tt>`</tt>




<p>
  <h1>CCC belülről</h1>
<p>
<i>Dr. Vermes Mátyás</i>
<p>
 2009. december
<p>
 
<h1> </h1> <a href="#tth_sEc1."
>1&nbsp; Bevezetés</a><br>
 <a href="#tth_sEc2."
>2&nbsp; Telepítés</a><br>
 <a href="#tth_sEc3."
>3&nbsp; Hello World</a><br>
 <a href="#tth_sEc4."
>4&nbsp; Változók</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1."
>4.1&nbsp; Deklaráció</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2."
>4.2&nbsp; Értékek</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3."
>4.3&nbsp; Típusok</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.1."
>4.3.1&nbsp; NIL</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.2."
>4.3.2&nbsp; Logikai</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.3."
>4.3.3&nbsp; Szám</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.4."
>4.3.4&nbsp; Dátum</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.5."
>4.3.5&nbsp; Pointer</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.6."
>4.3.6&nbsp; Karakter (Unicode string)</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.7."
>4.3.7&nbsp; Binary (bájt string)</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.8."
>4.3.8&nbsp; Array</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.9."
>4.3.9&nbsp; Kódblokk</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.10."
>4.3.10&nbsp; Objektum</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.11."
>4.3.11&nbsp; Referencia változók</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4."
>4.4&nbsp; Változótér</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5."
>4.5&nbsp; Szemétgyűjtés</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5.1."
>4.5.1&nbsp; Referencia számlálás</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5.2."
>4.5.2&nbsp; Mark and sweep</a><br>
 <a href="#tth_sEc5."
>5&nbsp; Függvényhívás</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1."
>5.1&nbsp; Független modulok</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2."
>5.2&nbsp; Láthatóság</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3."
>5.3&nbsp; Függvényhívás a veremgépen</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4."
>5.4&nbsp; Referencia paraméterek</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.5."
>5.5&nbsp; Default értékek</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.6."
>5.6&nbsp; Változó számú paraméter</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.7."
>5.7&nbsp; Névterek</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.8."
>5.8&nbsp; Postfix függvényhívás</a><br>
 <a href="#tth_sEc6."
>6&nbsp; Objektumok</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1."
>6.1&nbsp; Alapok</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2."
>6.2&nbsp; Öröklődési szabályok</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.3."
>6.3&nbsp; Attribútum/metódus invariancia</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4."
>6.4&nbsp; Metódus cast</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.5."
>6.5&nbsp; Láthatóság</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.5.1."
>6.5.1&nbsp; Static osztályok</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.5.2."
>6.5.2&nbsp; Névterek és osztályok</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.5.3."
>6.5.3&nbsp; Hivatkozás a class függvényre</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.6."
>6.6&nbsp; Defaulttól eltérő new függvény</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.7."
>6.7&nbsp; Metódushívás-továbbítás</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.8."
>6.8&nbsp; A könyvtári object osztály</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.9."
>6.9&nbsp; Függvény interfész</a><br>
 <a href="#tth_sEc7."
>7&nbsp; Kivételkezelés</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.1."
>7.1&nbsp; Mikor kapunk el kivételt?</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2."
>7.2&nbsp; A begin...recover utasítás</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.3."
>7.3&nbsp; Az errorblock</a><br>
 <a href="#tth_sEc8."
>8&nbsp; Többszálúság</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.1."
>8.1&nbsp; Pthread API</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2."
>8.2&nbsp; Egyszerű példa - mutex</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3."
>8.3&nbsp; Egyszerű példa - cond</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.4."
>8.4&nbsp; Thread-local storage</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.5."
>8.5&nbsp; Szálbiztonság</a><br>
 <a href="#tth_sEc9."
>9&nbsp; Unicode</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.1."
>9.1&nbsp; Unicode támogatás</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2."
>9.2&nbsp; További megfontolások, kompatibilitás</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.3."
>9.3&nbsp; Karakter/binary string literálok</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.3.1."
>9.3.1&nbsp; Karakter string</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.3.2."
>9.3.2&nbsp; Binary string</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.4."
>9.4&nbsp; Karakter/binary string függvények</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.5."
>9.5&nbsp; Internacionalizálás</a><br>
 <a href="#tth_sEcA."
>A&nbsp; Régebbi dokumentációk</a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEcA.1."
>A.1&nbsp;  <a href="http://ccc.comfirm.hu/pub/ng">Eredeti Clipper doksi</a> </a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEcA.2."
>A.2&nbsp;  <a href="http://ccc.comfirm.hu/ccc3/build.html">CCC projekt manager</a> </a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEcA.3."
>A.3&nbsp;  <a href="http://ccc.comfirm.hu/ccc3/jterminal.html">Jáva terminál</a> </a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEcA.4."
>A.4&nbsp;  <a href="http://ccc.comfirm.hu/ccc3/sql2.html">SQL2 interfész</a> </a><br>
 &nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEcA.5."
>A.5&nbsp;  <a href="http://ccc.comfirm.hu/ccc3/cccgtk.html">GTK interfész</a> </a><br>


<p>
 <h2><a name="tth_sEc1.">
1</a>.&nbsp;&nbsp;Bevezetés</h2>

<p>
A Clipper praktikus, egyszerű, általános célra használható eszköz volt. 
Nem véletlen a rendkívüli népszerűség, amire a maga idejében szert tett. 
A DOS-szal együtt azonban a Clipper kihalt,  az utána keletkezett űr 
betöltetlen maradt. A Clipper utódok, mint a Clip, FlagShip, Harbour nem 
terjedtek el széles körben, nálam egyik sem ,,nyerő", mint ahogy az új nyelvek sem.
A Jáva termelékenység helyett tudálékos, a Python túlságosan script ...

<p>
A CCC-t a banki programjainkkal párhuzamosan, saját célra fejlesztettük,
azzal az elgondolással, hogy a DOS korszak után a programokat ezzel fogjuk 
életben tartani.
Volt idő, amikor egyszerre DOS-on, Windowson és UNIX-(ok)on  
futottunk. Minden platformra ugyanabból a forrásból fordítottunk,
DOS-on Clipperrel, máshol CCC-vel. Ugyanabból a forrásból,
ez nem egy verziókezelő rendszerből elővett különféle változatokat jelent, 
hanem ténylegesen ugyanazokat a forrásfájlokat.

<p>
A CCC nem tud akármilyen Clipper kódot lefordítani. A programjainkat 
eleve egy szűkített Clipperre írtuk. A legfontosabb szűkítés, 
hogy a CCC-nek (mint nyelvnek) nem része az adatbáziskezelés. 
Mindenesetre a Clipper és a CCC közös része elég volt egy komplex 
számlavezető rendszer elkészítéséhez.
Amúgy a nyelv alkalmas akármilyen adatbáziskelő szoftver 
(manapság leginkább SQL interfész) megírására. 

<p>
Az eredeti Clipper a mostani igényeknek már nem felelne meg.
Idők során a Clipperen túllépő fejlesztések kerültek a CCC-be: 
objektumok,
kivételkezelés,
névterek, 
Unicode támogatás, SSL interfész, effélék.
A CCC-t  elég modernnek és jónak tartjuk ahhoz, 
hogy az új projektjeinkhez se keressünk más nyelvet.

<p>
A CCC történetének fő állomásai:

<ul>
<li> 1996 - Már működik a CCC1.
<p>
</li>

<li> 1999 - Először a BB-ben használják éles számlavezetésre.
<p>
</li>

<li> 2002 - Többszál támogatás (CCC2=CCC1+multithreading).
<p>
</li>

<li> 2004 - 64-bit támogatás.
<p>
</li>

<li> 2005 - <a href="http://www.fsf.org/licensing/licenses/lgpl.txt">LGPL</a> 
              hatálya alá kerül.
<p>
</li>

<li> 2006 - Unicode/UTF-8 támogatás (CCC3=CCC2+Unicode).
<p>
</li>
</ul>

<p>
A jelen dokumentáció a CCC3-mal foglalkozik.
A dokumentációt olyan programozóknak szánom, akik szeretnek beszélgetni
programokról, programozásról. Nem kezdőknek. A dokumentum nem ,,egyenszilárd".
Van benne Hello World, de nem szól fejezet a for ciklusról és társairól.
A Clippert meghaladó, új részekre fókuszálok,
ezen belül is elsősorban magára a nyelvre, 
és nem a nyelven megírt könyvtárakra vagy interfészekre.
A dokumentum végére belinkeltem néhány régi doksit.
A Clipper eredeti HTML leírása egyes részeiben még mindig használható.

<p>
 <h2><a name="tth_sEc2.">
2</a>.&nbsp;&nbsp;Telepítés</h2><a name="INSTALL">
</a>

<p>
A CCC többféle rendszeren fut: 
Windowson MinGW vagy Microsoft-C fordítóval.
Különféle Linuxokon, BSD-ken, Solarison GCC fordítóval.
Mi most az Ubuntu (Debian) Linuxon történő telepítést vesszük át.
Más platformokon (Windowson is) analóg módon kell eljárni.

<p>
Először  installáljuk a CCC-hez szükséges infrastruktúrát
az alábbi scripttel:

<p>

<pre>
#!/bin/bash

#&nbsp;Egy&nbsp;szokásos&nbsp;Ubuntu&nbsp;telepítés&nbsp;után
#&nbsp;ezeket&nbsp;a&nbsp;csomagokat&nbsp;kell&nbsp;felrakni,
#&nbsp;hogy&nbsp;a&nbsp;CCC2/CCC3&nbsp;leforduljon.
#&nbsp;+&nbsp;a&nbsp;jt-hez&nbsp;kell&nbsp;a&nbsp;Sun&nbsp;Java.
#&nbsp;+&nbsp;az&nbsp;SQL2-höz&nbsp;kell&nbsp;a&nbsp;PostgreSQL.

sudo&nbsp;apt-get&nbsp;install&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;g++&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;libncurses5-dev&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;libncursesw5-dev&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;manpages-dev&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;glibc-doc&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;libx11-dev&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;libxft-dev&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;libssl-dev&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;libpcre3-dev&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;libreadline6-dev&nbsp;\
&nbsp;&nbsp;&nbsp;&nbsp;git-core
#&nbsp;&nbsp;&nbsp;&nbsp;libgtk2.0-dev&nbsp;\
#&nbsp;&nbsp;&nbsp;&nbsp;libpangox-1.0-dev&nbsp;\

</pre>

<p>
Végrehajtjuk az alábbi parancsot:

<pre>
git&nbsp;clone&nbsp;&nbsp;git://comfirm.hu/ccc3.git

</pre>
Ehhez internet kapcsolat kell. Ha a parancsot a home-unkban adtuk ki, 
akkor létrejön a <tt>$HOME/ccc3</tt> directory, benne a CCC forrással.

<p>
A <tt>.bashrc</tt> fájlunkba beírjuk az alábbiakat:

<p>

<pre>
export&nbsp;CCCVER=3
export&nbsp;CCCDIR=$HOME/ccc3
export&nbsp;CCCBIN=lin
export&nbsp;CCCUNAME=linux
export&nbsp;CCCTERM_CONNECT="$CCCDIR/usr/bin/$CCCUNAME/terminal-xft.exe"
export&nbsp;CCCTERM_INHERIT=no
export&nbsp;CCCTERM_SIZE=80x40
export&nbsp;CCCTERM_XFTFONTSPEC=Monospace-11
export&nbsp;OREF_SIZE=50000

PATH=$CCCDIR/usr/bin/$CCCUNAME:$PATH
PATH=.:$PATH&nbsp;&nbsp;#fontos
LD_LIBRARY_PATH=$CCCDIR/usr/lib/$CCCBIN:$LD_LIBRARY_PATH
export&nbsp;PATH&nbsp;
export&nbsp;LD_LIBRARY_PATH
export&nbsp;LANG=en_GB.UTF-8&nbsp;&nbsp;#valamilyen&nbsp;UTF-8-as&nbsp;locale!

</pre>

<p>
Egyéb lehetséges variációk:

<p>
FreeBSD

<pre>
...
export&nbsp;CCCBIN=fre
export&nbsp;CCCUNAME=freebsd
...

</pre>

<p>
NetBSD

<pre>
...
export&nbsp;CCCBIN=net
export&nbsp;CCCUNAME=netbsd
...

</pre>

<p>
BSD-ken telepíteni kell a bash-t, és átlinkelni <tt>/bin/bash</tt>-be (hogy a
<tt>#!/bin/bash</tt> kezdetű scriptek fussanak). FreeBSD-n gondoskodni kell róla,
hogy legyen használható <tt>malloc.h</tt>.

<p>
Windows, MinGW

<pre>
...
set&nbsp;CCCBIN=mng
set&nbsp;CCCUNAME=windows
...

</pre>

<p>
Windows, Microsoft-C

<pre>
...
set&nbsp;CCCBIN=msc
set&nbsp;CCCUNAME=windows
...

</pre>

<p>
A Debiantól különböző rendszereken természetesen másképp kell megszerezni
a CCC függőségeit (nincs apt-get), de aki ilyeneket használ, 
az legyen tájékozott a kérdésben.

<p>
Ha most elindítunk egy terminált, abban a fent beállított környezet lesz érvényben
(ellenőrizzük). Bemegyünk a CCCDIR-be, és elindítjuk az <tt>i.b</tt> scriptet. 
Ez lefordítja az egész CCC-t (kivéve a Jáva terminált, amihez Jáva kell, 
és az SQL2 könyvtárat, amihez Postgres kell.) 
A CCC fordításának minden platformon warning mentesen kell futnia.

<p>
Ha a fordítás alapjaiban nem megy, akkor ellenőrizzük a környezet beállítását.

<p>
Ha egyes komponensek nem fordulnak, annak oka lehet, hogy hiányzik valami
függőség. Ilyenkor meg kell keresni, hogy konkrétan mi hiányzik, pótlólag telepíteni,
majd újraindítani az <tt>i.b</tt> scriptet.

<p>
Időről időre mégis megjelennek warningok, ez amiatt van, hogy a C++ fordító 
ellenőrzéseit szigorítják. A CCC karbantartása során ezek rendszeresen javításra 
kerülnek.

<p>
 <h2><a name="tth_sEc3.">
3</a>.&nbsp;&nbsp;Hello World</h2>

<p>
Készítünk egy directoryt, mondjuk <tt>$HOME/temp/hello</tt>, és abban egy 
<tt>hello.prg</tt> nevű fájlt.

<p>

<pre>
function&nbsp;main()
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"Hello&nbsp;World"

</pre>

<p>
Kiadjuk az alábbi parancsot:

<p>

<pre>
bapp_unix_.b

</pre>

<p>
amire létrejön (egyebek mellett) a <tt>hello.exe</tt> végrehajtható fájl. 
Ha ezt elindítjuk, a terminálban megjelenik a "Hello World" szöveg.

<p>
Nagyszerű!

<p>
De ne elégedjünk meg ennyivel, nézzünk szét a fájlok között.
Lett egy új directory, a <tt>ppo</tt>. Ide került a <tt>hello.ppo</tt> (PreProcessed Output)
fájl, amit a <tt>prg2ppo.exe</tt> makróprocesszor készített. Minden prg fájl átmegy
az előfeldolgozáson. A prg2ppo a C-ből ismerthez hasonló, de annál
bonyolultabb és nagyobb tudású előfeldolgozó. Az eredeti Clipperben szintén megvan
ez az előfeldolgozás. A mi előfeldolgozónk - amennyire csak lehetséges - kompatibilis
az eredetivel.

<p>
A <tt>ppo</tt> directoryban találjuk még a <tt>hello.cpp</tt> fájlt. Ezt a ppo-ból 
készíti a <tt>ppo2cpp.exe</tt> program, a tulajdonképpeni Clipper -&#62; C++ 
fordító. Később tanulmányozni fogjuk a generált cpp kódot.

<p>
A szintén újonnan létrejött <tt>objlin</tt> directoryba került a C fordítás eredménye,
a <tt>hello.obj</tt> fájl. Ha a projektben könyvtárak (lib, so) készülnének, azok is
itt, az <tt>objlin</tt> directoryban jönnének létre.

<p>
Próbáljuk ki a következőt. Újra kiadjuk a <tt>bapp_unix_.b</tt>
parancsot. Megjelenik a ,,CCC Program Builder 1.2.25 Copyright (C) ComFirm Bt."
felirat, de egyébként nem történik semmi. Módosítsuk a <tt>hello.prg</tt> fájlt,
és próbálkozzunk újra. Látjuk, hogy a program most újra lefordul. Akkor is 
beindul a fordítás, ha letöröljük az <tt>objlin</tt> directoryt, vagy csak egyik-másik
obj fájlt. Ha az exe-t töröljük le, akkor viszont beindul a linkelés.

<p>
Amire ki akarok lyukadni: A programkészítés elég komplex művelet.
A prg fájlokat át kell hajtani az előfeldolgozáson, a C fordításon, végül össze kell
őket linkelni más objectekkel és különféle statikus és dinamikus könyvtárakkal.
A CCC fejlesztő környezet ehhez igyekszik segítséget adni. A programozónak nem
kell leírnia, hogy melyik forrásfájlon milyen műveleteket akar végrehajtani.
Nincsenek make fájlok.

<p>
Projektben gondolkodunk. Egy directoryba beömlesztjük a projekthez tartozó
forrásfájlokat. A <tt>build.exe</tt> program átvizsgálja a forrásokat.
A kiterjesztésekből eleve tudja, hogy melyikkel milyen fordítási
műveletet lehet végezni. A fájlidőkből megállapítja, hogy mely fordítási
műveletek időszerűek. És ha már ilyen okos, akkor el is végzi a szükséges
műveleteket. 

<p>
A <tt>bapp_unix_.b</tt> script a <tt>build.exe</tt>-t indítja olyan 
paraméterezéssel, hogy az összes forrás lefordításával konzolos 
programot készítsen. A build széleskörűen paraméterezhető.
Meg lehet mondani neki, hogy a working directory helyett honnan vegye a forrásokat,
honnan vegye az include-okat, honnan vegye a statikus és dinamikus libeket,
ha van statikus és dinamikus lib is, akkor melyiket preferálja. Csináljon-e az 
objectekből libeket, ha készül exe, azt hova tegye. 

<p>
Akárhogy is, a build specialitása, 
hogy a forrásokat nem fájlonként, hanem directorynként
kell megadni neki. Ebből persze az következik, hogy a munkadirectory(k)ban nem
lehetnek más forrásfájlok, csak amik ténylegesen részei a projektnek. De ez nem
baj. A nem odavaló fájlokat egyszerűen félretesszük pl. egy <tt>nemkell</tt> nevű
subdirectoryba, így legalább tiszta marad a kép. Az is jó, hogy a fordítás során
keletkező rengeteg részeredmény subdirectorykba kerül, így a sok szemét nem
borítja el a fájlokat, amikkel ténylegesen dolgozunk.

<p>
További lényeges sajátossága a build (CCC projekt manager) programnak,
hogy nem csak prg, hanem cpp (sőt Lemon és Flex) forrásokat is automatikusan
áthajt a fordítási műveleteken. Tehát, ha egy directoryba összegyűjtünk egy rakás
Clipper, C++, Lemon, Flex forrást, azokból egy mozdulattal tudunk libeket,
exeket fordítani/linkelni. Ennek filozófiai jelentősége van. Mutatja ugyanis,
hogy a CCC nem szakadt el a C/C++ gyökerektől, hanem a Clipper és a C 
projektszinten keverhető.

<p>
Végül, szokássá vált, hogy a build-et indító parancsot (script nevet) beírjuk 
egy <tt>m</tt> nevű fájlba (scriptbe). A CCC programkészítés így az egybetűs 
<tt>m</tt> (make) parancsra indul.

<p>
 <h2><a name="tth_sEc4.">
4</a>.&nbsp;&nbsp;Változók</h2>

<p>
     <h3><a name="tth_sEc4.1.">
4.1</a>.&nbsp;&nbsp;Deklaráció</h3>

<p>
Minden változót deklarálni kell.
A deklaráció végrehajtható utasítás, helyet csinál a változónak, 
és végrehajtja a változó inicializátorát.
Az inicializátor tetszőleges kifejezés lehet,
ha nincs megadva explicit inicializátor, akkor a változó NIL-re inicializálódik.

<p>
Kétféle deklaráció lehetséges, <tt>local</tt> és <tt>static</tt>.

<p>

<pre>
/*
namespace&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;itt&nbsp;állhatna
using&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;itt&nbsp;állhatna
*/

static&nbsp;k1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;külső,&nbsp;NIL-re&nbsp;inicilizálódik
static&nbsp;k2:=init_k2()&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;visszatérési&nbsp;értékkel&nbsp;inicializálódik

function&nbsp;f1()
local&nbsp;a,&nbsp;b:=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;egyszerre&nbsp;több,&nbsp;némelyik&nbsp;inicializálva
static&nbsp;c,&nbsp;d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;belső&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;a,b,c,d,k1,k2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kiírja&nbsp;az&nbsp;értéküket
&nbsp;&nbsp;&nbsp;&nbsp;...

function&nbsp;f2(a1,a2,a3)
&nbsp;&nbsp;&nbsp;&nbsp;//?&nbsp;a,b,c,d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ezek&nbsp;nem&nbsp;láthatók
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;a1,a2,a3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;nem&nbsp;kell&nbsp;őket&nbsp;külön&nbsp;deklarálni&nbsp;(local)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;k1,k1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ok,&nbsp;ezek&nbsp;láthatók
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
A <tt>static</tt> deklarációk  is kétfélék:

<dl compact="compact">
 <dt><b>külsők</b></dt>
	<dd> a forrásmodul elején, 
        az esetleges <tt>namespace</tt> és <tt>using</tt> után,
        de az első <tt>function</tt> vagy <tt>class</tt> utasítás előtt állhatnak,</dd>
 <dt><b>belsők</b></dt>
	<dd> 
        függvények belsejében vannak, 
        közvetlenül a <tt>function</tt> utasítás után, 
        esetleg keveredve a <tt>local</tt> deklarációkkal,
        de megelőzve az összes nem deklarációs utasítást.</dd>
</dl>

<p>
A külső static változók csak a forrásmodulon belül, de ott minden függvényből láthatók. 
A belső static változók csak az adott függvényen belül láthatók. 
Egyáltalán nincsenek az egész programra kiterjedő globális láthatóságú változók.
A static változók inicializátora a program futása során egyszer hajtódik végre.
A static változók a program futása alatt nem vesztik el értéküket
(vagyis mindig őrzik az utolsó értékadással kapott értéket).
A belső static változók a függvény első hívásakor a leírt sorrendben inicializálódnak.
A külső static változók akkor inicializálódnak, amikor a program először hivatkozik 
az értékükre. A külső static változók inicializálása szinkronizált. A szinkronizáció 
biztosítja, hogy a külső static-ok többszálú programban se inicializálódjanak többször.
A belső static-oknál a szinkronizáció az alkalmazásra van bízva.

<p>
Egy local deklaráció mindig belső. 
A local deklarációk a belső static deklarációk helyén 
(azokkal esetleg keveredve) fordulhatnak elő. 
A local változók csak az adott függvényen belül láthatók. 
A local változók a függvény minden hívásakor inicializálódnak, ha másra nem, hát NIL-re.
Egyszerűen szólva, a <tt>local</tt> utasítás közönséges stack változókat deklarál.

<p>
Ha egy változót deklaráció nélkül próbálnánk használni, 
a fordító hibát jelez.

<p>
A függvények argumentum változóit nem kell (nem is lehet) külön deklaráni, 
ugyanúgy viselkednek mint a local változók.

<p>
Névegyezés esetén a local és a belső static változók eltakarják
a külső static változókat.

<p>
A változónevekben a kis- és nagybetűk egyformának számítanak.
Valójában az egész nyelv case insensitive, ami Clipper örökség,
és a kompatibilitás kényszere folytán nem változtatható.
A CCC-ben  megszokott, hogy túlnyomóan kisbetűket használunk.

<p>
A változó- és függvényneveket ugyanúgy képezzük, mint C-ben.
Néhány fenntartott kulcsszót 
(<tt>if</tt>, <tt>while</tt>, <tt>for</tt>, ...) 
kerülni kell.
A változó- és függvénynevek nem zavarják egymást (nem tudnak ütközni).

<p>
     <h3><a name="tth_sEc4.2.">
4.2</a>.&nbsp;&nbsp;Értékek</h3>

<p>
A Clipper/CCC-ben nem a változóknak, hanem elsősorban az <em>értékeknek </em> 
van típusa. Ez alapján persze utólag mondhatjuk, hogy egy változónak az a típusa, 
ami a benne tárolt értéknek. Az így értelmezett típus azonban minden
értékadáskor megváltozhat. A változók uniformok: Akármelyik változó képes tartalmazni 
akármilyen értéket. Ennek megfelelően a fordító nem foglalkozik a változók 
típusának ellenőrzésével. 

<p>
Nézzük, mi van egy értékben
(teljes infó a variable.h-ban):

<p>

<ul>
<li> Tartalmazza az érték típusát.
<p>
</li>

<li> Fix méretű adatoknál (mint szám, dátum, logikai) 
      tartalmazza magát az adatot.
<p>
</li>

<li> Változó méretű adatoknál (mint string, array)
      egy memóriaobjektum referenciát (OREF).
<p>
</li>

<li> Referencia változóknál egy VALUE referenciát (VREF).
<p>
</li>
</ul>

<p>
Úgy kell elképzelni, hogy egy változó a számára fenntartott memóriában
tartalmazza az előbb leírt struktúrájú <em>értéket</em>. Amikor a program
végrehajtja az 

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;a:=b

</pre>
<em>értékadást</em>, akkor a <tt>b</tt>-hez tartozó memóriaterületen tárolt <em>érték </em>
átmásolódik az <tt>a</tt>-hoz tartozó memóriaterületre. Vagyis <tt>a</tt> átveszi 
<tt>b</tt> típusát és minden adatát.  Különösen érdekes, amikor az adat egy referencia.
Ilyenkor a két változó közösködik ugyanazon a tartalmon.

<p>
     <h3><a name="tth_sEc4.3.">
4.3</a>.&nbsp;&nbsp;Típusok</h3>

<p>
Akármi is van a változóban,
a <tt>valtype()</tt> függvénnyel lekérdezhető az aktuális típusa. 
<tt>valtype()</tt> visszatérési értéke karakter típusú. 
A következő típusok vannak: 
NIL, logikai, szám, dátum, pointer, karakter (Unicode string),
binary (bájt string), array (érték tömb), kódblokk, objektum, referencia. 
Ezeket vesszük sorra az alábbiakban.

<p>
      <h4><a name="tth_sEc4.3.1.">
4.3.1</a>.&nbsp;&nbsp;NIL</h4>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;valtype(NIL)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"U"
&nbsp;&nbsp;&nbsp;&nbsp;len(NIL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;empty(NIL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.
&nbsp;&nbsp;&nbsp;&nbsp;NIL==3.141592&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.f.
&nbsp;&nbsp;&nbsp;&nbsp;NIL==NIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.

</pre>

<p>
Az explicite nem inicializált változók értéke NIL, típusjele U.
A <tt>return</tt> utasítás nélkül befejeződő függvények visszatérési
értéke NIL. A NIL hossza 0, a NIL üres, a NIL bármivel (bármilyen típussal)  
összehasonlítható, de csak saját magával egyenlő. (Általában
csak azonos típusú változók hasonlíthatók össze, a NIL ebben kivételes.)
A NIL-t már a típusa azonosítja, nem tartalmaz semmilyen adatot.

<p>
      <h4><a name="tth_sEc4.3.2.">
4.3.2</a>.&nbsp;&nbsp;Logikai</h4>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;valtype(.t.)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"L"&nbsp;&nbsp;(logikai&nbsp;true&nbsp;literál)
&nbsp;&nbsp;&nbsp;&nbsp;valtype(.f.)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"L"&nbsp;&nbsp;(logikai&nbsp;false&nbsp;literál)
&nbsp;&nbsp;&nbsp;&nbsp;empty(.t.)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.f.
&nbsp;&nbsp;&nbsp;&nbsp;empty(.f.)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.

</pre>

<p>
Logikai értéket adnak az összehasonlító operátorokkal képzett kifejezések.
A logikai értékekkel használható operátorok:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;.and.&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.,&nbsp;ha&nbsp;x==.t.&nbsp;és&nbsp;y==.t.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ha&nbsp;x==.f.,&nbsp;akkor&nbsp;y&nbsp;nem&nbsp;értékelődik&nbsp;ki

&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;.or.&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.,&nbsp;ha&nbsp;x==.t.&nbsp;vagy&nbsp;y==.t.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ha&nbsp;x==.t.,&nbsp;akkor&nbsp;y&nbsp;nem&nbsp;értékelődik&nbsp;ki
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;!&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.,&nbsp;ha&nbsp;x==.f.
&nbsp;&nbsp;&nbsp;&nbsp;.not.&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.,&nbsp;ha&nbsp;x==.f.&nbsp;(ugyanaz&nbsp;bőbeszédűen)

</pre>

<p>
A logikai műveletek precedenciája a szokásos, lehet zárójelezni.

<p>
      <h4><a name="tth_sEc4.3.3.">
4.3.3</a>.&nbsp;&nbsp;Szám</h4>

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;valtype(3.141592)&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"N"&nbsp;&nbsp;(szám&nbsp;literál)
&nbsp;&nbsp;&nbsp;&nbsp;empty(0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.&nbsp;&nbsp;(csak&nbsp;a&nbsp;0&nbsp;üres)
&nbsp;&nbsp;&nbsp;&nbsp;empty(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.f.

</pre>

<p>
A számok 64 bites lebegőpontos formában (double) tárolódnak. 
Többféleképpen is be lehet írni a programba szám literálokat, 
de a megadás módjától függetlenül a tárolás mindig double.

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;0xffff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;hexadecimális&nbsp;(mint&nbsp;C-ben)
&nbsp;&nbsp;&nbsp;&nbsp;0b11111111&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;bináris&nbsp;(255)

</pre>

<p>
A számokra működnek a szokásos összehasonlító műveletek.

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;==&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.,&nbsp;ha&nbsp;egyenlőek
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;!=&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.,&nbsp;ha&nbsp;eltérnek
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&lt;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kisebb
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&lt;=&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kisebbegyenlő
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&#62;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;nagyobb
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&#62;=&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;nagyobbegyenlő

</pre>

<p>
Megvannak a szokásos aritmetikai operátorok.

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;+&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;összeadás
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;-&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kivonás
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;*&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;szorzás
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;/&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;osztás
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;%&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;moduló
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;**&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;hatványozás
&nbsp;&nbsp;&nbsp;&nbsp;++x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;növelés&nbsp;(mint&nbsp;C-ben)
&nbsp;&nbsp;&nbsp;&nbsp;--x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;csökkentés&nbsp;(mint&nbsp;C-ben)
&nbsp;&nbsp;&nbsp;&nbsp;x++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;növelés&nbsp;utólag&nbsp;(mint&nbsp;C-ben)
&nbsp;&nbsp;&nbsp;&nbsp;x--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;csökkentés&nbsp;utólag&nbsp;(mint&nbsp;C-ben)

</pre>
A műveletek precedenciája ugyanaz, mint C-ben, és természetesen ugyanúgy
alkalmazható a zárójelezés.

<p>
A C-hez hasonlóan az aritmetikai operátoroknak van  értékadással
kombinált változata:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;+=&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;x:=x+y&nbsp;(hozzáad)
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;-=&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;x:=x-y&nbsp;(levon)
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;*=&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;x:=x*y
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;/=&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;x:=x/y
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;%=&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;x:=x%y

</pre>

<p>
Vannak számokon működő matematikai függvények:
<tt>power()</tt>,
<tt>exp()</tt>,
<tt>log()</tt>,
<tt>sqrt()</tt>,
trigonometrikus függvények,
<tt>round()</tt>,
<tt>random()</tt>.

<p>
Van néhány függvény bitek manipulálására:
<tt>isbit()</tt>,
<tt>setbit()</tt>,
<tt>clearbit()</tt>,
<tt>numand()</tt>,
<tt>numor()</tt>,
<tt>numxor()</tt>,
<tt>numnot()</tt>.

<p>
Az <tt>str()</tt> és <tt>transform()</tt> 
függvények számot karakter stringre konvertálnak.
A <tt>val()</tt> függvény  a string elején álló decimális
számból kiolvassa a számértéket.

<p>
      <h4><a name="tth_sEc4.3.4.">
4.3.4</a>.&nbsp;&nbsp;Dátum</h4>

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;date&nbsp;format&nbsp;"yyyy-mm-dd"
&nbsp;&nbsp;&nbsp;&nbsp;valtype(ctod("2009-11-20"))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"D"&nbsp;&nbsp;(nincs&nbsp;dátum&nbsp;literál)
&nbsp;&nbsp;&nbsp;&nbsp;valtype(stod("20091120"))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"D"
&nbsp;&nbsp;&nbsp;&nbsp;empty(ctod(""))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.
&nbsp;&nbsp;&nbsp;&nbsp;empty(date())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.f.

</pre>

<p>
Dátumokat nem tudunk közvetlenül (literálként) beírni a programba,
hanem a <tt>ctod()</tt> vagy <tt>stod()</tt> konverziós függvénnyel állítjuk
elő a string alakból. (E függvényeknek az inverze is létezik: 
<tt>dtoc()</tt>, <tt>dtos()</tt>.)

<p>
A dátumkezelés 1900-tól 2100-ig működik jól. Ebben az időszakban
helyesen kezeli a szökőéveket.

<p>
A dátumokra értelemszerűen működnek az összehasonlító operátorok.

<p>
A dátumokon korlátozottan lehet aritmetikai műveleteket végezni.
Az alábbi példában <tt>n</tt> szám típusú, <tt>d1</tt> és <tt>d2</tt>
dátum típusú:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;&nbsp;:=&nbsp;d2&nbsp;-&nbsp;d1&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;a&nbsp;két&nbsp;dátum&nbsp;különbsége&nbsp;napokban
&nbsp;&nbsp;&nbsp;&nbsp;d2&nbsp;:=&nbsp;d1&nbsp;+&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;d1&nbsp;dátum&nbsp;plusz&nbsp;n&nbsp;nap
&nbsp;&nbsp;&nbsp;&nbsp;d2&nbsp;:=&nbsp;d1&nbsp;-&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;d1&nbsp;dátum&nbsp;minusz&nbsp;n&nbsp;nap

</pre>

<p>
Van egy rakás dátumokon működő függvény:
<tt>doy()</tt>,
<tt>eom()</tt>,
<tt>eoy()</tt>,
<tt>bom()</tt>,
<tt>boy()</tt>,
<tt>day()</tt>,
<tt>dow()</tt>,
<tt>cdow()</tt>,
<tt>month()</tt>,
<tt>addmonth()</tt>,
<tt>cmonth()</tt>,
<tt>year()</tt>.

<p>
      <h4><a name="tth_sEc4.3.5.">
4.3.5</a>.&nbsp;&nbsp;Pointer</h4>

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;valtype(p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"P"&nbsp;&nbsp;(nincs&nbsp;pointer&nbsp;literál)
&nbsp;&nbsp;&nbsp;&nbsp;empty(p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.&nbsp;&nbsp;(csak&nbsp;a&nbsp;null&nbsp;pointer&nbsp;üres)

</pre>

<p>
A pointereket interfészekben használjuk. Arra való, hogy C könyvtárak
adatait (tipikusan egy struktúrára mutató pointert) tároljunk benne Clipper szinten.
Példa: Az Oracle minden SQL utasításhoz rendel egy ún. statement handle-t (pointer).
A program erre a statement handle-re kell hivatkozzon, amikor műveleteket
akar végezni az SQL utasítással, pl.  le akarja kérdezni egy select
eredménysorait. Egy ilyen statement handle tárolása oldható meg a P típusú
változóval.

<p>
      <h4><a name="tth_sEc4.3.6.">
4.3.6</a>.&nbsp;&nbsp;Karakter (Unicode string)</h4>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;valtype("Van,&nbsp;aki&nbsp;forrón&nbsp;szereti")&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"C"
&nbsp;&nbsp;&nbsp;&nbsp;len("")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;len("123")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;3
&nbsp;&nbsp;&nbsp;&nbsp;empty("")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.
&nbsp;&nbsp;&nbsp;&nbsp;empty("&nbsp;&nbsp;")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.&nbsp;(csak&nbsp;blank)
&nbsp;&nbsp;&nbsp;&nbsp;empty("x")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.f.

</pre>

<p>
Példák:

<pre>
local&nbsp;x:='ТЕРМИНЫ&nbsp;И&nbsp;УСЛОВИЯ&nbsp;КОПИРОВАНИЯ'
local&nbsp;y:=@"Some&nbsp;like&nbsp;it&nbsp;hot"&nbsp;&nbsp;//nlstext

local&nbsp;text:=&lt;&lt;tetszoleges_symbol&#62;&#62;
&nbsp;&nbsp;&nbsp;&nbsp;Itt&nbsp;tetszőleges&nbsp;(UTF-8&nbsp;kódolású)&nbsp;szöveg&nbsp;lehet,
&nbsp;&nbsp;&nbsp;&nbsp;idézőjelek,&nbsp;tab,&nbsp;soremelés,&nbsp;akármi,
&nbsp;&nbsp;&nbsp;&nbsp;kivéve&nbsp;a&nbsp;kezdő&nbsp;&lt;&lt;tetsz...&#62;&#62;&nbsp;(nem&nbsp;írhatom&nbsp;oda)&nbsp;jelet,
&nbsp;&nbsp;&nbsp;&nbsp;mert&nbsp;az&nbsp;lezárja&nbsp;a&nbsp;string&nbsp;literált.
&lt;&lt;tetszoleges_symbol&#62;&#62;&nbsp;//lezárva

</pre>

<p>
A karakterváltozók (stringek) Unicode karakterek sorozatát tartalmazzák.
A karakterváltozók tudják a saját hosszukat. Nincs lezáró 0, nincs vizsgálva 
a karakterek érvényessége, ezért a karakterek között akármilyen kódérték 
előfordulhat. A karakterváltozók hossza csak azért van korlátozva, hogy az 
elszabadult programok ne fektessék ki a rendszert. Jelenleg egy karakterstring 
maximális mérete 64MB. 

<p>
A karakterliterálokat UTF-8 kódolással kell beírni. 
A fordító végzi el a konverziót UTF-8-ról Unicode (<tt>wchar_t</tt>) tömbre.
Ha az  UTF-8 kódolás hibás, a fordító INVALIDENCODING hibát ad.

<p>
A stringeket aposztróf vagy macskaköröm határolja.
Aposztróffal határolt string tartalmazhat macskakörmöt, és fordítva.
A stringben nem lehet escape szekvenciákkal trükközni.

<p>
Alapesetben a stringek egysorosak. 
Hosszabb stringeket részeiből összeadással és folytatósorokkal lehet képezni.

<p>
A hosszabb (többsoros) stringek egyszerű beírását teszi lehetővé 
a <tt>&lt;&lt;SYMBOL&gt;&gt;</tt> típusú határoló.

<p>
A <tt>@"..."</tt> alakú stringekből (nlstext) a fordító készít egy hash táblát, 
amiben a string értéke a kulcs. A kulcsokhoz különféle nyelvű szövegeket
(fordításokat) lehet kapcsolni, amiket a program futás közben felszed,
és automatikusan behelyettesít, így ugyanaz a program különféle nyelveken 
jelenhet meg.

<p>
Bárhogy is hoztuk létre a stringet,  ugyanazokat a dolgokat lehet
csinálni vele.

<p>
Összehasonlítás:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;==&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;egyenlő-e&nbsp;(ez&nbsp;az&nbsp;egy&nbsp;normális)
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;!=&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;jobboldal&nbsp;hosszában&nbsp;eltér-e
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&lt;=&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;jobboldal&nbsp;hosszában!&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&lt;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;jobboldal&nbsp;hosszában!&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&#62;=&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;jobboldal&nbsp;hosszában!&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&#62;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;jobboldal&nbsp;hosszában!&nbsp;

</pre>

<p>
A stringek rendezése a Unicode kódértékek szerint lexikografikusan történik.
A <tt>==</tt> kivételével a többi összehasonlító operátor úgy működik,
hogy először a baloldalt levágja a jobboldal hosszára, és az így kapott
x-szel végzi az összehasonlítást, tehát:

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;"abc"&nbsp;!=&nbsp;"ab"&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.f.
&nbsp;&nbsp;&nbsp;&nbsp;"ab"&nbsp;&nbsp;!=&nbsp;"abc"&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.
&nbsp;&nbsp;&nbsp;&nbsp;"abc"&nbsp;&#62;&nbsp;&nbsp;"ab"&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.f.
&nbsp;&nbsp;&nbsp;&nbsp;"abc"&nbsp;&lt;=&nbsp;"ab"&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.

</pre>
Sajnos ezek elég zavaró dolgok, de Clipper örökség,
és a kompatibilitás kényszere miatt nem lehet rajta változtatni.

<p>
Összeadás:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;y:="Some&nbsp;like&nbsp;"+"it&nbsp;hot"
&nbsp;&nbsp;&nbsp;&nbsp;x:="Some&nbsp;like&nbsp;"
&nbsp;&nbsp;&nbsp;&nbsp;x+="it&nbsp;hot"
&nbsp;&nbsp;&nbsp;&nbsp;x==y&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.

</pre>

<p>
Indexelés, szeletek:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;"Some&nbsp;like&nbsp;it&nbsp;hot"[1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"S",&nbsp;indexelhető,&nbsp;1-től&nbsp;indul
&nbsp;&nbsp;&nbsp;&nbsp;"Some&nbsp;like&nbsp;it&nbsp;hot"[2..4]&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"ome",&nbsp;szelet
&nbsp;&nbsp;&nbsp;&nbsp;"Some&nbsp;like&nbsp;it&nbsp;hot"[11..]&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"it&nbsp;hot"
&nbsp;&nbsp;&nbsp;&nbsp;"Some&nbsp;like&nbsp;it&nbsp;hot"[..11]&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"Some&nbsp;like&nbsp;i"
&nbsp;&nbsp;&nbsp;&nbsp;"Some&nbsp;like&nbsp;it&nbsp;hot"[..]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;másolat&nbsp;az&nbsp;egészről

</pre>
A túlindexelés runtime errort okoz. 
A szeletek túllógó indexei módosulnak a tényleges méretekhez alkalmazkodva. 
Nincs trükközés, hátulról számolás, meg effélék.

<p>
Részstring tartalmazás:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;"like"&nbsp;$&nbsp;"Some&nbsp;like&nbsp;it&nbsp;hot"&nbsp;//&nbsp;--&#62;&nbsp;.t.

</pre>

<p>
A stringeken működő fontosabb függvények: 
<tt>strtran()</tt>, 
<tt>stuff()</tt>, 
<tt>substr()</tt>, 
<tt>left()</tt>, 
<tt>right()</tt>, 
<tt>padr()</tt>,
<tt>padl()</tt>, 
<tt>ltrim()</tt>, 
<tt>rtrim()</tt>, 
<tt>alltrim()</tt>, 
<tt>at()</tt>, 
<tt>rat()</tt>, 
<tt>len()</tt>, 
<tt>replicate()</tt>,
<tt>upper()</tt>,
<tt>lower()</tt>,
<tt>isalpha()</tt>,
<tt>isdigit()</tt>,
<tt>isalnum()</tt>,
<tt>isupper()</tt>,
<tt>islower()</tt>.

<p>
<tt>upper()</tt>, <tt>isupper()</tt> és társaik értik a Unicodeot, 
ezért cirill betűs stringre is jól működnek.

<p>
A <tt>chr(code)</tt> függvény visszaad egy egy hosszúságú stringet,
ami a megadott kódértékű (Unicode) karaktert tartalmazza.
Az <tt>asc(str)</tt> függvény visszaadja a bemeneti string első karakterének
kódértékét.

<p>
A karakterstring értékekben közvetlenül tárolódó adat 
(ahogy korábban már szó esett róla) egy OREF. Az <tt>a:=b</tt>
értékadás után az <tt>a</tt> és <tt>b</tt> változó közösködik
az objektumreferencián. Ugyanaz az értékük, ráadásul a string csak egy 
példányban létezik a memóriában. Mi történik, ha az egyik változót módosítjuk?

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;b+="próba&nbsp;szerencse"

</pre>
Változik-e <tt>b</tt>-vel együtt az <tt>a</tt>-is? Nem, a változók útja szétválik.
Lesz egy külön memóriaobjektuma <tt>a</tt>-nak és egy másik a <tt>b</tt>-nek.
Ez az értelme annak a más nyelvek dokumentációiban olvasható, kissé rejtélyes
kijelentésnek, hogy a ,,karakterstring (érték) nem módosítható". 

<p>
      <h4><a name="tth_sEc4.3.7.">
4.3.7</a>.&nbsp;&nbsp;Binary (bájt string)</h4>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;valtype(a"Próba&nbsp;szerencse")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"X"
&nbsp;&nbsp;&nbsp;&nbsp;valtype(x"0d0a")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"X"&nbsp;(CR/LF)
&nbsp;&nbsp;&nbsp;&nbsp;len(a"")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;len(a"123")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;3
&nbsp;&nbsp;&nbsp;&nbsp;empty(a"")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.
&nbsp;&nbsp;&nbsp;&nbsp;empty(a"&nbsp;&nbsp;")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.&nbsp;(csak&nbsp;blank)
&nbsp;&nbsp;&nbsp;&nbsp;empty(a"x")&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.f.

</pre>

<p>
A binary változók (bájt stringek) bájtok sorozatát tartalmazzák.
Tudják a saját hosszukat. Nincs lezáró 0, ezért a bájtok között akármilyen érték 
előfordulhat. A binary változók hossza csak azért van korlátozva, hogy az 
elszabadult programok ne fektessék ki a rendszert. Jelenleg egy binary string
maximális mérete 64MB. 

<p>
Legegyszerűbben az <tt>a"..."</tt> alakban írhatók be egy programba:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x:=a"Van,&nbsp;aki&nbsp;'forrón'&nbsp;szereti"
&nbsp;&nbsp;&nbsp;&nbsp;y:=a'Van,&nbsp;aki&nbsp;"forrón"&nbsp;szereti'

</pre>

<p>
A karakterliterálokhoz képest az a különbség,
hogy most nincs UTF-8 -&#62; Unicode konverzió, 
a tartalom nem karaktertömb, hanem bájttömb.

<p>
A stringeket aposztróf vagy macskaköröm határolja.
Aposztróffal határolt string tartalmazhat macskakörmöt, és fordítva.
Nem értelmezünk semmilyen escape szekvenciát.

<p>
Hexadecimális kódokkal is megadhatjuk a bájtsorozatot a <tt>x"..."</tt>
formában. Ennek kötelezően páros számú betűt kell tartalmaznia 
(minden bájt egy kétjegyű hexa szám: 00-ff), a kis-nagybetű nem számít.

<p>
A binary változókra ugyanazok az operátorok és függvények működnek,
mint a karakterváltozókra, csak értelemszerűen karakterek helyett bájtokkal.
Pl. <tt>asc()</tt> most nem az első karakter, hanem az első bájt kódértékét adja.
A <tt>bin(code)</tt> függvény ad egy egyelemű bájtsorozatot, melyben az egyetlen
elem értéke a <tt>code</tt>.

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;binvar:=str2bin(chrvar)
&nbsp;&nbsp;&nbsp;&nbsp;chrvar:=bin2str(binvar)&nbsp;&nbsp;//visszaadja&nbsp;az&nbsp;eredetit

</pre>

<p>
Az <tt>str2bin()</tt> függvény a bemeneti karaktersorozatból
előállít egy bájtsorozatot, ami a stringet UTF-8 kódolásban ábrázolja.

<p>
A <tt>bin2str()</tt> függvény <em>feltételezi</em>, hogy a bemenete egy UTF-8 
kódolású szöveg, és UTF-8 -&#62; Unicode konverzióval előállítja a bájtsorozatnak
megfelelő karaktersorozatot. Ha a bemenet mégsem kifogástalan UTF-8 kódolású,
akkor a hibák helyén ? karakterek jelennek meg a kimeneten.  Emiatt az 
str2bin és bin2str nem egymás inverzei. Pl. egy png képet tartalmazó 
binary változót nem lehet oda-vissza karakterre konvertálni, mert elromlik a kép.

<p>
A bájtsorozatok és karakterek között nincs automatikus konverzió, 
ezért pl. nem lehet őket összeadni vagy összehasonlítani.

<p>
A karakterekhez hasonlóan a bájt string értékekben is a közvetlenül tárolódó 
adat egy OREF. Ugyanolyan értelemben most is mondhatjuk, hogy (első közelítésben)
a bájt stringek nem módosíthatók.  Igazából természetesen minden módosítható.
Van rá API, hogy a programok dogozhassanak a bufferen belül.

<p>
      <h4><a name="tth_sEc4.3.8.">
4.3.8</a>.&nbsp;&nbsp;Array</h4>

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;valtype({1,"2",.f.,{}})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"A"
&nbsp;&nbsp;&nbsp;&nbsp;len({})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;len(array(1000))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;1000
&nbsp;&nbsp;&nbsp;&nbsp;empty({})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.t.
&nbsp;&nbsp;&nbsp;&nbsp;empty(array(1000))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.f.

</pre>

<p>
Az array (tömb) típus Clipper értékek sorozatát tartalmazza.
A tömbelemek típusa bármi lehet, bármilyen értéket tartalmazhat
elemként, akár saját magát is (ami persze végtelen rekurziót okoz
a tömb kiprintelésekor).

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;a:={}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;üres&nbsp;array
&nbsp;&nbsp;&nbsp;&nbsp;{1,2,3,4}[3]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;3,&nbsp;az&nbsp;indexek&nbsp;1-től&nbsp;indulnak
&nbsp;&nbsp;&nbsp;&nbsp;{1,2,3,4}[2..3]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;{2,3},&nbsp;array&nbsp;szelet
&nbsp;&nbsp;&nbsp;&nbsp;len({1,2,3,4})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;4,&nbsp;tudja&nbsp;a&nbsp;saját&nbsp;hosszát
&nbsp;&nbsp;&nbsp;&nbsp;array(10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;NIL-ekkel&nbsp;inicializált,&nbsp;10&nbsp;elemű
&nbsp;&nbsp;&nbsp;&nbsp;a[i]:=x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;értékadás&nbsp;egy&nbsp;tömbelemnek
&nbsp;&nbsp;&nbsp;&nbsp;a[i][j]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;i-edik&nbsp;elemének&nbsp;j-edik&nbsp;eleme
&nbsp;&nbsp;&nbsp;&nbsp;aadd(a,x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;végéhez&nbsp;ad&nbsp;egy&nbsp;új&nbsp;elemet
&nbsp;&nbsp;&nbsp;&nbsp;asize(a,len(a)+1)&nbsp;&nbsp;&nbsp;//&nbsp;hossz&nbsp;növelése

</pre>

<p>
A futtatórendszer minden indexelést ellenőriz, 
túlindexelés esetén runtime error keletkezik. 

<p>
A stringekhez hasonlóan alkalmazható a szeletelés, ami a tömb megadott részéről
sekély másolatot készít. A szeletekben túllógó indexek nem okoznak runtime errort,
hanem automatikusan alkalmazkodnak a tényleges méretekhez.

<p>
Az inicializálatlan tömbelemek értéke NIL.

<p>
A tömbökön használható fontosabb függvények:
<tt>array()</tt>,
<tt>asize()</tt>,
<tt>adel()</tt>,
<tt>aadd()</tt>,
<tt>atail()</tt>,
<tt>ascan()</tt>,
<tt>asort()</tt>.

<p>
Az array típusú értékekben a közvetlenül tárolt adat egy OREF.
Az OREF-hez tartozó memóriaobjektumban a tömbelemek szépen, 
katonásan egymás után sorakoznak.
A stringekre azt mondtuk, hogy nem változtathatók.
A tömbök ezzel szemben igen, a különbséget az alábbi példa
szemlélteti.

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;a:=array(10)
&nbsp;&nbsp;&nbsp;&nbsp;b:=a
&nbsp;&nbsp;&nbsp;&nbsp;b[5]:="HOPP"
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;a[5]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kiírja:&nbsp;HOPP

</pre>

<p>
Láttuk, hogy a tömbök mérete változhat. 
Emiatt a futtatórendszer időnként az egész tömböt 
kénytelen áthelyezni új memóriacímre.

<p>
      <h4><a name="tth_sEc4.3.9.">
4.3.9</a>.&nbsp;&nbsp;Kódblokk</h4>

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;valtype({||NIL})&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"B"
&nbsp;&nbsp;&nbsp;&nbsp;len({||x})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;(ref&nbsp;változók&nbsp;száma)
&nbsp;&nbsp;&nbsp;&nbsp;empty({||NIL})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.f.&nbsp;&nbsp;(sosem&nbsp;üres)

</pre>

<p>
Amit más nyelvekben (Lisp, Python, Smalltalk,...) úgy hívnak, hogy closure vagy
lambda-függvény, az a Clipperben a kódblokk. Általános alakja: 

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;blk:={|p1,p2,...|expr1,expr2,...}

</pre>
A <tt>||</tt> jelek között vannak felsorolva a kódblokk paraméterei (lehet üres).
Ezután kifejezések vesszővel elválasztott listája következik. A kifejezésekben 
a kódblokk paraméterei, plusz a kódblokk definiálásának helyéről látható, érvényes
programelemek (literálok, változók, függvények) szerepelhetnek. 

<p>
A kódblokk értelme, hogy ki lehet őt értékelni. Az előbbi <tt>blk</tt>
változót átadjuk az <tt>eval</tt> függvénynek:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;eval(blk,a1,a2,...)&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;az&nbsp;utolsó&nbsp;kifejezés&nbsp;értéke

</pre>
Az a1, a2, ... értékek behelyettesítődnek, a p1, p2, ... változókba,
majd kiértékelődnek az expr1,expr2,... kifejezések. Az utolsó kifejezés
értéke lesz az eval függvény visszatérési értéke.

<p>
A Clipper/CCC-ben nincs olyan, hogy függvénypointer. Ha a programban leírunk 
egy függvénynevet  zárójelpár (azaz függvényhívás operátor) nélkül, 
akkor az szándékainkkal ellentétben nem a függvényt jelenti, hanem egy változónevet, 
és hibát kapunk, ha az adott néven nincs változó deklarálva. 

<p>
A kódblokkok legegyszerűbb alkalmazása függvények paraméterként való átadása.
Nézzünk egy összeadó függvényt:

<pre>
function&nbsp;osszead(a,b)
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a+b

</pre>
Ebből készítünk egy kódblokkot:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;blk:={|p1,p2|osszead(p1,p2)}

</pre>
A blk változó értéke átkerül a program egy másik helyére, 
pl. visszatérési értékként, vagy függvényparaméterként. 
Ezen a másik helyen így értékelhető ki:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;eval(blk,1,2)&nbsp;//&nbsp;--&#62;&nbsp;3

</pre>

<p>
Rendkívül érdekes tulajdonsága a kódblokkoknak, hogy a blokk kifejezéslistájában
szerepelhetnek változók abból a láthatósági körből, ahol a kódblokkot
definiáltuk. A kódblokk révén ezek a változók láthatóvá válnak olyan helyen,
ahol egyébként normálisan nem volnának láthatók: Külső static változó egy másik 
modulban, vagy belső változó egy másik függvényben. Úgy szoktuk mondani,
hogy a kódblokkba ,,belerefesednek" a változók (lásd a referencia változókat).

<p>

<pre>
function&nbsp;main()
local&nbsp;x,blk:={|p|x+=p}

&nbsp;&nbsp;&nbsp;&nbsp;x:="a"
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;proba1(blk)&nbsp;&nbsp;&nbsp;//kiírja:&nbsp;a-proba1
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//kiírja:&nbsp;a-proba1

&nbsp;&nbsp;&nbsp;&nbsp;x:="b"
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;proba1(blk)&nbsp;&nbsp;&nbsp;//kiírja:&nbsp;b-proba1
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//kiírja:&nbsp;b-proba1
&nbsp;&nbsp;&nbsp;&nbsp;?
&nbsp;&nbsp;&nbsp;&nbsp;
function&nbsp;proba1(blk)&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;eval(blk,"-proba1")

</pre>
Most van min tűnődni:
Kétszer (ugyanúgy?) meghívtuk a <tt>proba1</tt> függvényt,
ám a két alkalommal más-más eredményt kaptunk. 
Ráadásul, hogyan változhat meg az <tt>x</tt> értéke,
ami a <tt>main</tt>-en belül lokális, és így máshol nem látható?

<p>
A kódblokk egy másik tulajdonságára világít rá a következő példa:

<pre>
function&nbsp;main()
local&nbsp;blk:=proba1()
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;eval(blk,"HOPP")&nbsp;&nbsp;//&nbsp;kiírja&nbsp;"Próba&nbsp;szerencse:HOPP"
&nbsp;&nbsp;&nbsp;&nbsp;?

function&nbsp;proba1()&nbsp;&nbsp;&nbsp;&nbsp;
local&nbsp;x:="Próba&nbsp;szerencse:"
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;{|p|x+p}

</pre>
A nagy kérdés itt, hol tárolódik a "Próba szerencse:" érték?
A kódblokk kiértékelésekor (<tt>main</tt>-ben) a <tt>proba1</tt> már visszatért,
tehát az <tt>x</tt> változó már nem létezik. A válasz: az érték a kódblokkban tárolódik.

<p>
A kódblokkban közvetlenül tárolódó adatok:

<ul>
<li> kódpointer a kifejezéslistára (erre adja a vezérlést az <tt>eval()</tt>),
<p>
</li>

<li> OREF a kifejezéslistában szereplő változókból képzett tömbre.
<p>
</li>
</ul>
A kódblokkba kerülő változók referenciák. Ez azt jelenti, hogy az eredeti
és a kódblokkban tárolt példányok együtt változnak (ez a ,,belerefesedés").

<p>
A kódblokk a Clipper nagyon sokoldalúan használható eszköze.
Többek között a kódblokkokon alapul az objektum-metódusok implementációja.

<p>
      <h4><a name="tth_sEc4.3.10.">
4.3.10</a>.&nbsp;&nbsp;Objektum</h4>

<p>
Vannak ún. <em>objektum alapú </em> nyelvek.
Ezekben egy objektumot úgy képzelhetünk el, mint egy hashtáblát.
Az objektum-hashtáblában az attribútumok/metódusok neve a kulcs.
A hash a kulcs mellé az attribútum értékét, illetve a metódus
implementációját képviselő kódblokkot rendeli. A metódushívás
a kódblokk automatikus kiértékelésével történhet. Minden objektum
egyedi, bármikor bővíthető új attribútum/metódussal.

<p>
Ezzel az egyszerű megközelítéssel szemben a CCC-ben <em>osztályok </em> vannak.
Objektumok helyett  az osztályok leírására használunk hashtáblát.
A hashben most is az attribútumok/metódusok neve a kulcs,
az attribútum kulcsokhoz azonban most egy indexet rendelünk.
Ennél az indexnél található meg az érték az objektum attribútumai között.
Maga az objektum csak az attribútumaiból áll. 
A lényeg, hogy <em>megkülönböztetjük</em>, és elkülönítve tároljuk <em>az osztály- 
és objektum-információt</em>.

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;valtype(o:=errorNew())&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"O"
&nbsp;&nbsp;&nbsp;&nbsp;len(o)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;14&nbsp;&nbsp;&nbsp;(attribútumok&nbsp;száma)
&nbsp;&nbsp;&nbsp;&nbsp;empty(o)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;.f.&nbsp;&nbsp;(len(o)==0)
&nbsp;&nbsp;&nbsp;&nbsp;o:classname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;"error"

</pre>

<p>
Objektumokat nem operátorral gyártunk
(nincs new operátor), hanem objektumgyártó függvénnyel.
Ezek nevét az osztály nevéből (a példában <tt>error</tt>) 
és a <tt>New</tt> szóból rakjuk össze. 
Az xNew függvény visszatérési értéke az x osztályú
objektum. A régi Clipperben is ez volt a helyzet, az error objektumokat 
az <tt>errorNew()</tt> függvény adta. A kompatibilitás érdekében megtartottuk
a sémát. Az objektumgyártó függvényt a fordító generálja az osztálydefinícióból.

<p>
Az objektumok <tt>valtype()</tt> szerinti típusa osztályuktól 
függetlenül mindig O. 

<p>
Minden osztály az <tt>object</tt> osztály leszármazottja, ezért mindnek
van <tt>classname</tt> metódusa, amivel lekérdezhető az osztály neve.

<p>
A futtatórendszer statikusan tárolja az osztályokra vonatkozó infót:

<ul>
<li> a leszármazási viszonyokat (többszörös öröklődés),
<p>
</li>

<li> az osztályok szerkezetét
        (milyen metódusai, attribútumai vannak egy osztálynak, 
        mit honnan örökölt),
<p>
</li>

<li> az attribútum indexeket (melyik attribútum, hanyadik az attribútumok tömbjében),
<p>
</li>

<li> a metódusok kódját (a kód kódblokk formájában adatként tárolható).
<p>
</li>
</ul>
A fentiek tehát osztályadatok. 

<p>
Az objektumokban tárolódó adatok:

<ul>
<li> osztály azonosító,
<p>
</li>

<li> OREF az objektum attribútumait tartalmazó tömbre.
<p>
</li>
</ul>

<p>
Ha a fordítóprogram az <tt>obj:slot</tt> kifejezéssel találkozik,
akkor felismeri, hogy attribútum kiértékelésről vagy metódushívásról van szó.
Elkészíti a megfelelő kódot, de nem vizsgálja <tt>obj</tt> típusát/osztályát,
sem a <tt>slot</tt> attribútum/metódus létezését.

<p>
Futásidőben a kifejezés kiértékelése többféle eredményre vezethet. 
Ha <tt>obj</tt> típusa nem objektum, akkor azonnal runtime error keletkezik. 
A rendszer megkeresi <tt>obj</tt> osztályában a <tt>slot</tt> kulcsot.
Ha nem találja, akkor megintcsak runtime error keletkezik. 
Ha a kulcsnál attribútum indexet talál, akkor előveszi az attribútum értékét.
Ha kódblokkot talál, akkor azt automatikusan kiértékeli.

<p>
Talán már nem is kéne külön említeni, hogy a stringekkel szemben
az objektumok változékonyak (teljesen ugyanaz a helyzet, mint az array típusnál):

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;e1:=errorNew()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;minden&nbsp;tag&nbsp;üres
&nbsp;&nbsp;&nbsp;&nbsp;e2:=e1
&nbsp;&nbsp;&nbsp;&nbsp;e2:description:="Próba&nbsp;szerencse"
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;e1:description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kiírja:&nbsp;"Próba&nbsp;szerencse"

</pre>

<p>
Az osztálydefiníciókkal külön fejezetben fogunk részletesen foglalkozni.

<p>
      <h4><a name="tth_sEc4.3.11.">
4.3.11</a>.&nbsp;&nbsp;Referencia változók</h4>

<p>
Nézzük az alábbi példát:

<pre>
function&nbsp;main()
local&nbsp;a:="A"
local&nbsp;b:="B"
&nbsp;&nbsp;&nbsp;&nbsp;felkialt(@a,b)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;a,b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kiírja:&nbsp;A!&nbsp;B
&nbsp;&nbsp;&nbsp;&nbsp;
function&nbsp;felkialt(x,y)
&nbsp;&nbsp;&nbsp;&nbsp;x+="!"
&nbsp;&nbsp;&nbsp;&nbsp;y+="!"
&nbsp;&nbsp;&nbsp;&nbsp;varstack()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kiírja&nbsp;a&nbsp;stacket
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;valtype(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kiírja:&nbsp;C&nbsp;(x&nbsp;típusa)
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NIL

</pre>

<p>
Közönséges esetben a függvényhívás értékek átadásával történik.
A hívó kód a veremre rakja a paramétereket (a-t, aztán b-t) és meghívja
a függvényt (esetünkben felkialt-ot). A hívott függvény csinál, amit csinál,
majd rendbeteszi maga után a stacket. Az összes local változóját és paraméterét
leszedi a stackről. Ekkor a stacken az első üres hely ott van, 
ahol a függvény első paramétere volt (esetünkben az x). Ezután ráteszi a stackre 
a visszatérési értékét (esetünkben NIL-t), és visszatér.

<p>
Nade, akkor mitől változik meg az <tt>a</tt> változó értéke?
A magyarázat, hogy a tárgyalt eset nem ,,közönséges". 
Figyeljük meg a <tt>felkialt(@a,b)</tt> függvényhívásban az <tt>a</tt> előtti
<tt>@</tt> karaktert. Ennek hatására az <tt>a</tt> változó <em>referenciává </em> alakul.

<p>
A referencia változók az értéküket nem közvetlenül tartalmazzák.
Amit közvetlenül tartalmaznak, az egy VREF (VALUE referencia).
Ez direkt azt a célt szolgálja, hogy több változó közösködni
tudjon egy értéken, és ennek az értéknek a változásával
a változók együtt változzanak.

<p>
Nézzük az előbbi példaprogram tényleges kiírásait:

<pre>
-----------------------------------------------------------
&nbsp;Variable&nbsp;Stack
-----------------------------------------------------------
*****&nbsp;function&nbsp;main
0:&nbsp;REFSTRING&nbsp;length=2&nbsp;oref=7fd95b61b058&nbsp;"A!"
1:&nbsp;STRING&nbsp;length=1&nbsp;oref=7fd95b61b028&nbsp;"B"
*****&nbsp;function&nbsp;felkialt
2:&nbsp;REFSTRING&nbsp;length=2&nbsp;oref=7fd95b61b058&nbsp;"A!"
3:&nbsp;STRING&nbsp;length=2&nbsp;oref=7fd95b61b088&nbsp;"B!"
-----------------------------------------------------------
C
A!&nbsp;B

</pre>
Gyönyörűen látszik, hogy <tt>a</tt> és <tt>x</tt> együtt változnak,
míg <tt>b</tt> és <tt>y</tt> külön életet élnek.
(Honnan? <tt>a</tt> és <tt>x</tt> oref-je azonos, és a <tt>main</tt>-beli
<tt>a</tt> már a <tt>felkialt</tt> visszatérése előtt tartalmazza a ! jelet.
<tt>b</tt> és <tt>y</tt> viszont külön oref-fel rendelkeznek.)

<p>
Még egy kérdés: A <tt>varstack</tt> kiírása szerint <tt>x</tt> típusa 
REFSTRING, a <tt>valtype()</tt> szerint viszont a típus C (közönséges karakter). 
Hogy is van ez? Éppen ebben nyilvánul meg, hogy a futtatórendszer 
támogatja a referencia változókat. Amikor úgy látja, hogy a változó
(aminek az értékét elő kell venni) referencia típusú, akkor nem a
közvetlenül tárolt referenciát adja, hanem ,,derefeli", azaz eggyel tovább 
nyúl, és a valódi értéket veszi elő. Ezért a <tt>valtype()</tt>  a ,,derefelt"
értékkel hívódik meg. 

<p>
Automatikusan kezeli a rendszer
a referenciákat az értékadások mindkét oldalán.

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;refvar:=x

</pre>
Az <tt>x</tt> változó (az értéket tartalmazó memóriaterület) nem
<tt>refvar</tt> memóriaterületére másolódik, hanem oda, ahová <tt>refvar</tt>
hivatkozik. Ezért <tt>refvar</tt> referencia típusa megmarad.

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x:=refvar

</pre>
Hasonlóképp, <tt>refvar</tt> derefelt értéke íródik <tt>x</tt>-be,
ezért az <tt>x</tt> változó nem válik referenciává.

<p>
     <h3><a name="tth_sEc4.4.">
4.4</a>.&nbsp;&nbsp;Változótér</h3>

<p>
A következőkben egy gráfot fogunk vizsgálni.

<p>
Vegyük fel a csúcsok közé a program statikus változóinak tömbjét.
A programban nem találkozunk ilyen tömbbel, mégsem értelmetlen beszélni
róla, ui. a statikus változók szakasztott ugyanúgy tárolódnak, mint egy array:
az értékek szépen, katonásan egymás után sorakoznak a memóriában.

<p>
Vegyük fel a csúcsok közé a program stackjeit (vermeit). 
Hogyhogy több? Igen, minden szál külön stackkel rendelkezik.
Ezen tárolódnak a local változók, a függvényparaméterek, 
a kifejezések részeredményei. Egy stacket is tekinthetünk tömbnek, 
csak éppen a hossza változik, ahogy a stackpointer szuszog.
(A félreértések elkerülése végett: 
Nem a C program stackjéről van szó.
A futtatórendszernek saját stackje van,
amire CCC értéket tesz a push, és CCC értéket vesz le róla a pop.)

<p>
Vegyük fel a csúcsok közé mindazon memóriaobjektumokat,
amiket a program valaha létrehozott, és még nem szabadított fel:
tömbök, objektumok, kódblokkok, referencia változók, stringek.

<p>
A stringek kivételével az összes eset a tömbök mintájára tárgyalható.
Az objektumok esetében az attribútumok tömbjéről van szó.
Kódblokkoknál a blokkba refesedett változók alkotnak tömbszerű
képződményt. A referencia változók kicsit speciálisak,
de ezeket is tekinhetjük egyelemű tömböknek, amiket a futtatórendszer
automatikusan indexel. Ezek a csúcsok tehát minden esetben értéktömbök. 
Memóriaterület, amiben a korábban tárgyalt típusú <em>értékek </em> helyezkednek 
el egymás után.

<p>
A string memóriaobjektumok viszont biztosan nem tartalmaznak 
<em>értékeket</em>, hiszen tudjuk róluk, hogy csak bájtokat vagy Unicode
karaktereket tartalmaznak.

<p>
Látjuk tehát, hogy a csúcsaink egy részében értékek vannak, és ezek
között lehetnek referencia típusúak, amikben a közvetlenül tárolt adat egy
OREF vagy VREF.  
Vegyünk fel a gráfban irányított éleket, amik a referenciát tartalmazó csúcsokból 
(memóriaobjektumokból) a hivatkozott memóriaobjektumokba (csúcsokba) mutatnak.

<p>
Összefoglalva: 
A gráf csúcsai a program memóriaobjektumai, beleértve
a statikus változók tömbjét, a stackeket, a tömböket, objektumokat,
kódblokkokat, referencia változókat és stringeket. Az irányított élek
megfelelnek a hivatkozásoknak. Hivatkozik, értsd: olyan elemet tartalmaz,
ami nem közvetlenül tartalmazza az értékét, hanem egy memóriaobjektumban.
A stringek olyan csúcsok, amikből nem indul él. Az egyszerű típusok
(szám, dátum, logikai, pointer, NIL) a gráf szempontjából érdektelenek.

<p>
     <h3><a name="tth_sEc4.5.">
4.5</a>.&nbsp;&nbsp;Szemétgyűjtés</h3>

<p>
Sokadszor, újra nézzük meg az értékadást.

<pre>
local&nbsp;x:="Próba"+"&nbsp;"+"szerencse"

&nbsp;&nbsp;&nbsp;&nbsp;//most&nbsp;van&nbsp;egy&nbsp;"Próba&nbsp;szerencse"&nbsp;tartalmú&nbsp;memóriaobjektum,
&nbsp;&nbsp;&nbsp;&nbsp;//amire&nbsp;az&nbsp;x&nbsp;változó&nbsp;hivatkozik,&nbsp;következésképp&nbsp;a&nbsp;stackből&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;//(mint&nbsp;csúcsból)&nbsp;él&nbsp;mutat&nbsp;erre&nbsp;a&nbsp;memóriaobjektumra

&nbsp;&nbsp;&nbsp;&nbsp;x:=NIL

&nbsp;&nbsp;&nbsp;&nbsp;//az&nbsp;előbbi&nbsp;él&nbsp;törölve,&nbsp;mi&nbsp;lesz&nbsp;a&nbsp;memóriaobjektummal?

</pre>

<p>
A fenti példa mutatja a ,,szemét" képződésének legegyszerűbb esetét.
A programból a továbbiakban már sehol sem látszik a <tt>"Próba&nbsp;szerencse"</tt> érték,
nincs mód hozzáférni, ha megint ugyanez az érték kell, akkor újra le kell gyártani.
Az ilyen elérhetetlenné (és így feleslegessé) vált memóriaobjektumok megszüntetését
nevezik szemétgyűjtésnek.

<p>
      <h4><a name="tth_sEc4.5.1.">
4.5.1</a>.&nbsp;&nbsp;Referencia számlálás</h4>

<p>
Az idők hajnalán a CCC-nek is volt referencia számlálással működő kísérleti változata.
Nem véletlenül. A referencia számlálás egyszerűnek látszik, ez az, ami először eszébe 
jut a dilettáns programozónak.

<p>
A változótér  minden csúcsában
nyilvántartjuk a befutó élek számát. Az előbb láttuk, hogy az éleket
a legegyszerűbben az értékadó utasítások módosítják. Egyes élek törlődnek,
mások létrejönnek. Vannak más esetek is, amikor az élek módosulnak. Akárhogy is,
megtehetjük, hogy minden módosuláskor a befutó
élek számát (referenciaszám) aktualizáljuk. Amikor ez a szám nullára csökken, 
akkor az adott memóriaobjektum törölhető. (Persze a stackeket sosem töröljük.)

<p>
Ezen az elven működik a Python szemétgyűjtése.

<p>
A referencia számlálás sajnos több sebből vérzik. 
Gondot okoznak a körök. 
A változótérben lehetnek körök, nagyon egyszerű ilyet csinálni, pl.

<pre>
local&nbsp;a:={NIL}
&nbsp;&nbsp;&nbsp;&nbsp;a[1]:=a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ez&nbsp;itt&nbsp;egy&nbsp;hurok

</pre>
A körben résztvevő csúcsok referenciaszáma sosem csökken nullára. 
Ez egy elvi probléma.

<p>
Gyakorlati probléma, hogy nehézkes a referencia számlálós rendszerekben
a programozás. A referenciaszám karbantartása ui. az API részévé válik,
és sok esetben nem világos, hogy kinek a feladata a  referenciaszámot módosítani,
és milyen időzítéssel kell azt végrehajtani.

<p>
Bár előnyei is lehetnek, 
a szakemberek körében a referenciaszámlálás presztízse nem áll valami magasan,
inkább más módszereket preferálnak. Sokan a referenciaszámlálást nem is tekintik
,,igazi" szemétgyűjtésnek.

<p>
      <h4><a name="tth_sEc4.5.2.">
4.5.2</a>.&nbsp;&nbsp;Mark and sweep</h4>

<p>
Az igazi szemétgyűjtő algoritmusok legegyszerűbb változata a
<em>mark and sweep </em> algoritmus. A program időről időre (amikor fogytán van
a memória, amikor éppen ráér, amikor úgy gondolja, hogy már régen
nem csinálta) beindítja a szemétgyűjtést.

<p>

<ul>
<li> A <em>mark </em> (=bejelöl) szakaszban a kezdő csúcsokból
    (esetünkben a static változókból és a stackekből) kiindulva bejárja
    a gráfot és útközben bejelöli, hogy mely csúcsokba (memóriaobjektumokba)
    jutott el. Ezek a program élő adatai.
<p>
</li>

<li> A <em>sweep </em> (=kisöpör) szakaszban végigmegy az összes csúcson
    (memóriaobjektumon), és kitörli azokat, amiket a mark szakasz nem jelölt
    be élőnek.
<p>
</li>
</ul>

<p>
Ez van a CCC-ben, ennek is a legegyszerűbb magvalósítása. 
A szemétgyűjtés bele van építve a futtatórendszerbe, 
ezért tudja, hogyan kell bejárni a gráfot,
és hogyan kell végigmenni az összes memóriaobjektumon.
A memóriafoglalás és felszabadítás a <tt>malloc</tt> és 
<tt>free</tt> (Windowson <tt>GlobalAlloc</tt> és <tt>GlobalFree</tt>)
függvényhívásokkal történik. Vagyis a memóriakezelés egyszerűen 
rá van lőcsölve az operációs rendszerre.

<p>
Igen, mielőtt először kipróbáltam, én is aggódtam, nem fogja-e a primitív
memóriakezelés túlterhelni az operációs rendszert. Nem terheli túl.
A pentiumos korszaktól kezdve a CCC gyorsan és vidáman fut.

<p>
Egy átlagos CCC program memóriafoglalása nem kirívóan nagy. 
Miközben ezt a szöveget írom, megnéztem a top-ban, mennyi a <tt>z.exe</tt>
(CCC-ben írt editor) memóriafoglalása. A legtöbb memóriát a <tt>firefox-bin</tt>
foglalja (55M), a <tt>z.exe</tt> (8M) a tizedik helyen áll, 
az <tt>xfce4-menu-plugin</tt> után és az <tt>xterm</tt> előtt.
Ugyanakkor van CCC program, amelyik egyszerre többmillió memóriaobjektummal
rendelkezik, és gigabájtnyi helyet foglal. Mindezt nem dicsekvésnek szánom,
csak annyit mondok, hogy a modern operációs rendszerek
elég jól kezelik a memóriát, nem érdemes azt alkalmazásszinten újraírni.

<p>
A mark and sweep algoritmusnak is vannak hátrányai.
A szemétgyűjtés kampányszerűen történik, ilyenkor a program minden 
más tevékenységet felfüggeszt. Átlagos méretű programoknál a szünet 
tizedmásodpercekben mérhető, amit interaktív használatban nem lehet észrevenni.
A legnagyobb (többmillió objektumos) programokban a szünet 2-3 másodperc.
Mindenesetre lehetnek olyan feladatok, robotvezérlés, effélék, ahol semmilyen
szünet nem megengedhető, ilyesmire a CCC nem alkalmas. (Egyébként a Jáva
licencében is leírják, hogy atomerőművek és repülőgépek vezérlésére nem jó.)

<p>
 <h2><a name="tth_sEc5.">
5</a>.&nbsp;&nbsp;Függvényhívás</h2>

<p>
     <h3><a name="tth_sEc5.1.">
5.1</a>.&nbsp;&nbsp;Független modulok</h3>

<p>
Függvény és függvényhívás a Clipper/CCC legfontosabb építőkövei. 
Mielőtt azonban a kövek részleteit vizsgálnánk, nézzünk az épület egészére.

<p>
Egy projekt általában sok forrásmodulból áll. A modulok neve legyen mondjuk

<pre>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;code1.prg
&nbsp;&nbsp;&nbsp;&nbsp;code2.prg
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;code100.prg

</pre>
A fordító ezeket egyesével lefordítja, és kapjuk a

<pre>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;code1.obj
&nbsp;&nbsp;&nbsp;&nbsp;code2.obj
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;code100.obj

</pre>
object (gépi kód) fájlokat. Lehet, hogy a prg források egy részével nem találkozunk 
közvetlenül, mert egy másik projektben készülnek, és mi már csak a lefordított 
objecteket kapjuk. Utóbbi  esetben az a tipikus, hogy az objectek nem külön-külön, 
hanem könyvtárakba (statikus lib, vagy dinamikus so) összecsomagolva állnak 
rendelkezésre. Ez a helyzet a futtatórendszer alapkönyvtáraival is,
amit minden program használ. Akárhogy is, a lényeg, hogy rendelkezésünk áll 
egy rakás object fájl. Ezekből lesz a program.

<p>
A <em>linker </em> (link editor) feladata, hogy az egymástól függetlenül 
létrehozott, egymásról mit sem tudó nagy rakás object fájlból futtatható 
programot szerkesszen (linkeljen).

<p>
Tegyük fel, hogy a projektünk végterméke egy közvetlenül elindítható program
(nem pedig könyvtár). Akkor a modulok valamelyikében kell legyen <tt>main</tt>
függvény, ahol elindul a program. Mondjuk a <tt>code1.prg</tt>-ben.

<pre>&nbsp;
function&nbsp;main()
local&nbsp;x,a,b,c
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;x:=fuggveny1(a,b,c)
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
Program nem létezhet függvényhívás nélkül.
Már a <tt>main</tt>-re is függvényhívással kerül a vezérlés 
a futtatórendszer alapkönyvtárából. A main aztán meghívhat további
függvényeket, mint a példában <tt>fuggveny1</tt>-et, aminek a belsejében 
további függvényhívás lehet, és így tovább. 

<pre>&nbsp;
function&nbsp;fuggveny1(a,b,c,d)
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;fuggveny2()
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
A körnek végül záródnia kell, az összes meghívott függvény
kódja meg kell legyen valahol az összeszerkesztett modulokban: 
az alapkönyvtárakban, plusz a <tt>code1.obj</tt>... modulokban.

<p>
Az előbb ,,egymásról mit sem tudó" modulokról beszéltünk.
Ez azt jelenti, hogy a fordítóprogram semmit (a nevükön kívül semmi egyedit)
nem tud a függvényekről. A fordítóprogram a <tt>fuggveny1</tt> fordításakor
látja, hogy kódot kell generálnia a <tt>fuggveny2</tt> meghívására. Miközben
ezt megteszi nem tudja, hogy a <tt>fuggveny2</tt> hol van definiálva,
definiálva van-e egyáltalán, milyen paraméterezéssel kell meghívni,
milyen visszatérési értéket ad.

<p>
Persze nem tudnánk értelmes programot írni, 
ha nem volnánk tisztában a függvények paraméterezésével, 
visszatérési értékével, de ezt nem a fordító tudja, hanem a programozó. 
A dokumentációból vagy a forrásprogram  elolvasásából. 
A fordítóprogram szempontjából minden függvényhívás ugyanolyan,
mindegyik ugyanarra a kaptafára húzható.

<p>
C-ből nézve minden Clipper függvény 

<pre>
extern&nbsp;void&nbsp;_clp_fuggveny1(int&nbsp;argno);&nbsp;//C++&nbsp;kód

</pre>
deklarációval rendelkezik, azaz C szinten nincs visszatérési értéke (void), 
és egyetlen int paramétere van, ami megmondja,  hány paramétert 
kapott Clipper szinten. Clipper szinten minden függvénynek van visszatérési
értéke, ha más nincs megadva, akkor NIL. 

<p>
Ha a Clipper/CCC programozó kap egy bináris object fájlt 
(vagy lib/so könyvtárat) és tudja, hogy mi a fájl tartalma, 
akkor minden további nélkül belinkelheti a programjába, használhatja.
A C programozók számára ez merőben szokatlan. 
C/C++-ban egy könyvtár használatához múlhatatlan szükség van az ún. header 
fájlokra (forrás típusú fájlok), amik segítik a fordítót a kódgenerálásban és 
a függvényhívások ellenőrzésében.

<p>
A gyakorlatban a változók, függvények, objectek, könyvtárak
(egymásra épülő, egymást feltételező) uniform mivolta azt eredményezi, 
hogy egymástól függetlenül fordított modulok, könyvtárak összelapátolásával 
rendkívüli termelékenységgel hozhatunk létre óriási programokat.

<p>
     <h3><a name="tth_sEc5.2.">
5.2</a>.&nbsp;&nbsp;Láthatóság</h3>

<p>
Eddig csak globális láthatóságú függvényekről beszéltünk.
Természetesen nem szerencsés, ha egy belső használatra szánt
függvény mindenhonnan látszik, és ki van téve a tervezettől eltérő használatnak
vagy akár csak véletlen névütközésnek.
A függvényeinket forrásmodulon belül eldughatjuk <tt>static</tt> definícióval:

<pre>
static&nbsp;function&nbsp;fuggveny1()
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
Egy static függvény csak abban a forrásmodulban látható, amiben definiálták. 
Clipper/CCC-ben és C-ben a <tt>static</tt> szó ugyanazt jelenti,
változó deklarációban és függvény definícióban egyaránt.
A static függvények C-ben is static-ok:

<pre>
static&nbsp;void&nbsp;_clp_fuggveny1(int&nbsp;argno);&nbsp;//C++&nbsp;kód

</pre>

<p>
     <h3><a name="tth_sEc5.3.">
5.3</a>.&nbsp;&nbsp;Függvényhívás a veremgépen</h3>

<p>
Most megnézzük a részleteket,
hogyan valósul meg a ,,uniform" függvényhívás a CCC veremgépén.

<p>

<pre>
local&nbsp;x,a,b,c,d
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;x:=fuggveny1(a,b,c)
&nbsp;&nbsp;&nbsp;&nbsp;fuggveny1()
&nbsp;&nbsp;&nbsp;&nbsp;fuggveny1(,,c,d)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//ua.&nbsp;mint&nbsp;fuggveny1(NIL,NIL,c,d)
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
A függvényeket akárhány darab és akármilyen típusú paraméterrel 
meg lehet hívni. A függvény mindig ad visszatérési értéket, amit viszont
nem kötelező felhasználni. A fenti programrészlet talán furcsának látszik,
de formailag hibátlan. Hogy jó-e, az csak futáskor dől el. 
Lehetséges, hogy <tt>fuggveny1</tt> úgy van megírva, hogy megvizsgálja
a paramétereit, és a konkrét esettől függően csinál ezt vagy azt.

<p>
Nézzük a dolgokat a hívott függvényből.

<pre>
function&nbsp;fuggveny1(a,b,c)
local&nbsp;x:=0
&nbsp;&nbsp;&nbsp;&nbsp;x+=if(a==NIL,0,a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//NIL&nbsp;helyett&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;x+=if(b==NIL,0,b)
&nbsp;&nbsp;&nbsp;&nbsp;x+=if(c==NIL,0,c)
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x

</pre>
Itt egy példa <tt>fuggveny1</tt> viszonylag értelmes implementációjára.
Akkor működik jól, ha NIL vagy szám típusú paramétereket kap. Összeadja
a paraméterek számértékét (a NIL-ek helyett nullát vesz), és visszaadja az összeget.

<p>
Ha egy paraméter nincs megadva, annak a futtatórendszer 
NIL értéket ad. Nincs megadva: a paraméterlista rövid vagy hézagos.
A NIL értékeket a példaprogram nullával helyettesíti.

<p>
Ha a paraméterlista hosszabb 3-nál, akkor a fölös paramétereket 
a futtatórendszer eldobja. Az előző példában <tt>d</tt> mintha ott se lenne.

<p>
Ha a paraméterek között valamilyen más típus van, pl. logikai, 
az valamelyik összeadásban fog kiderülni. A program ,,elszáll",
és egyúttal kiírja, hogy melyik sorban milyen értékeket nem lehetett összeadni, 
valamint kiírja az egész stacket. Ilyen a CCC hibakezelése.

<p>
Ha már a stacknél tartunk, egészítsük ki a példaprogramot, 
és nézzük meg a stacket:

<p>

<pre>
function&nbsp;main()
local&nbsp;x,a:=1,b:=2,c:=10,d:="d"
&nbsp;&nbsp;&nbsp;&nbsp;x:=fuggveny1(a,b+b)

function&nbsp;fuggveny1(a,b,c)
local&nbsp;x:=0
&nbsp;&nbsp;&nbsp;&nbsp;x+=if(a==NIL,0,a)
&nbsp;&nbsp;&nbsp;&nbsp;x+=if(b==NIL,0,b)
&nbsp;&nbsp;&nbsp;&nbsp;x+=if(c==NIL,0,c)
&nbsp;&nbsp;&nbsp;&nbsp;varstack()
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x

</pre>

<p>
A <tt>varstack()</tt> a futtatórendszer beépített függvénye,
kiírja a program összes static (most egy sincs) és local változóját.

<p>

<pre>
-----------------------------------------------------------
&nbsp;Variable&nbsp;Stack
-----------------------------------------------------------
*****&nbsp;function&nbsp;main
0:&nbsp;NIL
1:&nbsp;NUMBER&nbsp;1
2:&nbsp;NUMBER&nbsp;2
3:&nbsp;NUMBER&nbsp;10
4:&nbsp;STRING&nbsp;length=1&nbsp;oref=b79b6008&nbsp;"d"
*****&nbsp;function&nbsp;fuggveny1
5:&nbsp;NUMBER&nbsp;1
6:&nbsp;NUMBER&nbsp;4
7:&nbsp;NIL
8:&nbsp;NUMBER&nbsp;5
-----------------------------------------------------------

</pre>
A rendszer tudja, hogy a stacken hol vannak a függvényhívási határok.
Azt remélem, az olvasó bonyolult magyarázat nélkül is azonnal érti, amit lát.
A <tt>fuggveny1</tt> szintjét nézve vegyük át, hogyan zajlik le a függvényhívás,
végrehajtás, visszatérés.

<p>
    A hívó program sorban egymás után a stackre rakja a 
      paramétereket. Egy paraméter akármilyen bonyolult kifejezés lehet,
      szépen kiszámolódik, a végeredmény (a kifejezés értéke) a stack 
      tetején marad.  Az 5-ös és 6-os stack elemek a paraméterek.

<p>
    Meghívódik <tt>fuggveny1</tt>. Meg van mondva neki, 
      hogy 2 darab paramétert kapott. A stack állásából és 
      a kapott paraméterek számából tudja, hogy a saját szintje
      az 5-ös elemtől kezdődik, egyúttal megvan a paraméterek értéke.
      Azokat az argumentum változókat, amikre nem jutott paraméter, 
      NIL-re inicializálja. Így kerül <tt>c</tt> értekeként NIL a 7-es stack elembe.
      Az esetleges fölös paramétereket (most nincs ilyen) kipucolja.

<p>
    A <tt>fuggveny1</tt> további helyeket foglal magának a stacken
      a local változók számára (amiket inicializál is, bár ez most nem látszik).
      A 8-as stack elemben tárolódik az <tt>x</tt> változó.

<p>
    A hívott függvény elvégzi, amit kell. 
      Eközben a stack ,,szuszog". Részeredmények tárolódnak
      rajta, mélyül majd visszacsökken a függvényhívások szintje. 

<p>
    Elérkezik a visszatérés ideje. <tt>fuggveny1</tt> 
      az 5-ös elem helyére beírja a visszatérési értékét,
      majd beállítja a stackpointert, hogy a stack első szabad helyeként
      a 6-os elemet mutassa. Visszatér.    

<p>
    A hívó program szempontjából a függvényhívás egy <em>kifejezés </em> volt.
      Minden kifejezés úgy működik, hogy ,,kiszámolja magát", 
      és az értékét a stack tetején hagyja. Esetünkben a kifejezés értéke
      a visszatérési érték. Ezzel azt csinál a hívó program, amit akar.
      Ha semmit sem csinál, akkor az érték automatikusan lekerül a stackről,
      és elvész.

<p>
     <h3><a name="tth_sEc5.4.">
5.4</a>.&nbsp;&nbsp;Referencia paraméterek</h3>

<p>
Más nyelvekről szóló dokumentációkban találhatunk ilyen kijelentést:
,,A paraméterátadás érték szerint történik". Ez van a Clipper/CCC-ben is.

<p>
Írjuk át az előző példaprogramot.

<pre>
function&nbsp;fuggveny1(a,b,c)
&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;a==NIL&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a:=0
&nbsp;&nbsp;&nbsp;&nbsp;end
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a+b+c

</pre>
Így <tt>fuggveny1</tt> működése ugyanaz marad.
Felvetődik viszont a kérdés: Az <tt>a:=0</tt> értékadás miatt nem fordul-e elő,
hogy az <tt>a</tt> változó értéke a hívó programban is megváltozik? Nem. 
Aki figyelmesen olvasta az előző pontot, és követte, mi történik a vermen,
annak ez nyilvánvaló.

<p>
Bonyolultabb a referenciát tartalmazó típusok esete. 
String, array, objektum, kódblokk esetén is érték szerint történik a paraméterátadás, 
csakhogy ilyenkor az értékben közvetlenül tárolt adat egy OREF 
(memóriaobjektum referencia). Emiatt a hívó és hívott program ,,közösködik"
ugyanazon a tartalmon. 

<p>
Stringek esetében ez a közösködés readonly,  csak addig tart,
amíg a hívott program nem akar változtatni a stringen. Amikor változtat,
a hívó és hívott program változóinak tartalma szétválik.

<p>
Array, objektum, kódblokk esetén a hívott program megváltoztathatja
a memóriaobjektum <em>belsejét </em> (array esetén az array hosszát is).

<p>
Az eddigi ,,normál", és magától értetődő eseteken túl előfordul, 
hogy kifejezetten arra van szükség, 
hogy a hívott függvényben végrehajtott változtatás
a hívó program változójára is hasson. 
Ezt szolgálja a referencia szerinti paraméterátadás.

<p>

<pre>
function&nbsp;main()
local&nbsp;x,a,b:=2,c:=10,d:="d"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a==NIL
&nbsp;&nbsp;&nbsp;&nbsp;x:=fuggveny1(@a,b+b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;@a&nbsp;referencia
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kiírja:&nbsp;0

function&nbsp;fuggveny1(a,b,c)
&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;a==NIL&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a:=0
&nbsp;&nbsp;&nbsp;&nbsp;end
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;valtype(a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kiírja:&nbsp;N
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a+b+c

</pre>

<p>
Most az <tt>a</tt> változók <tt>main</tt>-ben és <tt>fuggveny1</tt>-ben együtt változnak.
A <tt>@a</tt> paraméterátadás hatására az eredetileg NIL típusú változó referenciává
alakul, és ez a referencia adódik át a hívott függvénynek. 
A referencia típusú változók kiolvasását/értékadását a futtatórendszer
speciálisan támogatja: Automatikusan eggyel ,,tovább nyúl" a tényleges
értékért anélkül, hogy ezt a programban jelölni kellene. Úgy képzelhetjük el, 
mint egy egy hosszúságú tömböt, aminek az indexelését a rendszer automatikusan
elvégzi.

<p>
Külön említendő, hogy a hívott program <em>nem tudja</em>, hogy az argumentumai
referenciák-e vagy sem. Nem tudja? Mit mond róla a <tt>valtype()</tt>?
Amikor <tt>valtype(a)</tt> meghívódik, akkor is működik a referencia típusok
speciális támogatása, azaz a rendszer eggyel tovább nyúlva előveszi  <tt>a</tt>
tényleges tartalmát, ezért <tt>valtype()</tt> úgy látja, hogy a kérdéses típus szám.

<p>
Eddig tartott a régi Clipper tudománya. 
Az eddig tárgyalt dolgokban CCC és Clipper között tökéletesnek mondható a kompatibilitás. 
A következők már a CCC újításai.

<p>
     <h3><a name="tth_sEc5.5.">
5.5</a>.&nbsp;&nbsp;Default értékek</h3>

<p>
A kényelmesebb programírás érdekében a függvénydefinícióban
default értéket adhatunk az argumentum változóknak. Még mindig
az előző példánál maradva, ezt is írhatjuk:

<p>

<pre>
function&nbsp;fuggveny1(a:=0,b:=0,c:=0)
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a+b+c

</pre>

<p>
Általánosságban

<pre>
function&nbsp;fuggveny(...,a:=expr,...)
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
pontosan ugyanazt jelenti, mint

<pre>
function&nbsp;fuggveny(...,a,...)
&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;a==NIL&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a:=expr
&nbsp;&nbsp;&nbsp;&nbsp;end
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
ahol <tt>expr</tt> tetszőleges olyan kifejezés, amit az adott helyen ki lehet
értékelni.

<p>
     <h3><a name="tth_sEc5.6.">
5.6</a>.&nbsp;&nbsp;Változó számú paraméter</h3>

<p>

<pre>
function&nbsp;fuggveny1(a,b,c)
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
Ez a függvény legfeljebb 3 darab paramétert tud átvenni. 
Ha kevesebbet kap, 
akkor NIL-re inicializálja a paraméter nélkül maradt argumentum változókat, 
ha többet kap, 
akkor a fölös paramétereket (esetünkben a 3 felettieket) kipucolja 
(mintha nem is lettek volna).

<p>
Olyan függvényre is szükség van, ami előre nem ismert számú paramétert vesz át.

<p>

<pre>
function&nbsp;fuggveny1(a,b,c,*)
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
Az <em>utolsó </em> argumentum változó helyén szereplő <tt>*</tt> azt jelöli,
hogy a függvény akárhány (további) paramétert átvesz. 

<p>
Minden korábbi szabály érvényes, kivéve, hogy nincsenek ,,kipucolódó"
paraméterek.  Nem tudjuk, hogy a hívó küldött-e akár csak 1 darab paramétert.
Ha igen, akkor az első, második, harmadik paraméter behelyettesítődik az
<tt>a</tt>,<tt>b</tt>,<tt>c</tt> argumentum változókba. Ha nem, akkor a rendszer
NIL-re inicializálja a paraméter nélkül maradtakat. 
A hívott program a kapott paraméterek számát 3-nál nagyobbegyenlőnek fogja látni.

<p>
Nem szükséges, hogy legyenek névvel ellátott argumentum változók.

<pre>
function&nbsp;fuggveny1(*)
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
Ez a változat egyszerűen minden paramétert átvesz.

<p>
No jó, ez a dolog egyik oldala, de hogyan férünk hozzá az ,,átvett", 
de változóhoz esetleg nem rendelt értékekhez? Az alábbi kifejezésekben

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;{*}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;array&nbsp;az&nbsp;összes&nbsp;paraméterből
&nbsp;&nbsp;&nbsp;&nbsp;fuggveny2(*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;függvényhívás
&nbsp;&nbsp;&nbsp;&nbsp;object:method(*)&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;metódushívás

</pre>
a <tt>*</tt> helyére behelyettesítődik a függvény összes paramétere. Elsőre 
talán furcsa, de a helyzet világos lesz a következő összehasonlítás után. 

<pre>
function&nbsp;fuggveny1(a,b,c)
local&nbsp;array1:={a,b,c}
local&nbsp;array2:={*}
local&nbsp;array3:={*,1,*}&nbsp;&nbsp;&nbsp;//&nbsp;{a,b,c,1,a,b,c}
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;fuggveny2(a,b,c)
&nbsp;&nbsp;&nbsp;&nbsp;fuggveny2(*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ugyanaz

</pre>
Hogyan készül az <tt>array1</tt> tömb? A rendszer a stackre rakja az 
<tt>a</tt>, <tt>b</tt>, <tt>c</tt> változók értékét, majd meghívja a veremgép
egy primitívjét, hogy a stack tetején levő három elemből készítsen tömböt.
Ez a primitív leveszi a három elemet, elkészíti a tömböt, és az eredményt
a stack tetején hagyja. Na, pontosan ugyanígy készül <tt>array2</tt> is,
az egyetlen különbség, hogy az elemek konkrét felsorolása helyett
csak annyit mondtunk: az összes paraméter. Ezzel meg is vagyunk.
<tt>len({*})</tt> megadja az összes paraméter számát (jelen esetben fix 3), 
<tt>{*}[n]</tt> megadja az <tt>n</tt>-edik paraméter értékét (a túlindexelés hiba).

<p>
Külön szólni kell a kódblokkokról.

<pre>
local&nbsp;blk1:={|p1,*|...}
local&nbsp;blk2:={|*|fuggvény(*)}

</pre>
A <tt>||</tt> jeleken belüli <tt>*</tt> a függvényekhez hasonlóan azt jelenti, 
hogy a kérdéses kódblokk minden paramétert átvesz. Itt is rendelhetünk
argumentumváltozót az elől álló paraméterekhez. A kódblokk kifejezéslistájában
szereplő (tehát a <tt>||</tt> jeleken kívüli) <tt>*</tt> az összes kódblokk paraméter
felsorolását jelenti.

<p>
A <tt>*</tt> (nem kifejezés, csak) jelölés
minden olyan kifejezésben működik, ahol értelme van a paraméterek
felsorolásának. Nézzünk néhány fontosabb esetet.

<pre>
function&nbsp;fuggveny1(*)
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fuggveny2(*)

</pre>
Itt <tt>fuggveny1</tt> továbbítja a hívást <tt>fuggveny2</tt>-nek, 
anélkül, hogy bármit tudna annak paraméterezéséről.
A <tt>*</tt> felsorolás függvény- és metódushívásban a referencia változók
referencia tulajdonságát megtartja, ezzel szemben a <tt>{*}</tt> kifejezésben 
a referenciák derefelődnek.

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;{|*|fuggveny(*)}

</pre>
A fenti kódblokk meghív egy függvényt továbbítva neki a blokk összes paraméterét.

<p>
A paraméterek felsorolásának vannak további esetei:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;*[x1..x2]&nbsp;&nbsp;//&nbsp;paraméterek&nbsp;x1-től&nbsp;x2-ig
&nbsp;&nbsp;&nbsp;&nbsp;*[x1..]&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;paraméterek&nbsp;x1-től&nbsp;(ameddig&nbsp;van)
&nbsp;&nbsp;&nbsp;&nbsp;*[..x2]&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;paraméterek&nbsp;x2-ig&nbsp;(1-től)
&nbsp;&nbsp;&nbsp;&nbsp;*[..]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;összes&nbsp;paraméter&nbsp;(*)

</pre>
A szintaktika a string szeletekhez hasonló. 
A túllógó indexek módosulnak a tényleges méretekhez alkalmazkodva.
Magyarázat helyett néhány példa:

<pre>
function&nbsp;fuggveny1(a,b,c)
local&nbsp;array1:={a,b,c}
local&nbsp;array2:={*[..]}&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ua.&nbsp;mint&nbsp;array1&nbsp;vagy&nbsp;{*}
local&nbsp;array3:={b,c}
local&nbsp;array4:={*[2..3]}&nbsp;&nbsp;//&nbsp;ua.&nbsp;mint&nbsp;array3

</pre>
A függvényhívás továbbítás (esetleg kódblokkon keresztül) fontos szerepet
kap a metódushívások implementációjában.

<p>
     <h3><a name="tth_sEc5.7.">
5.7</a>.&nbsp;&nbsp;Névterek</h3>

<p>
Korszerű programnyelv nem nélkülözheti a névtereket.
A forrásmodulok legelején állhat az opcionális 
<tt>namespace</tt> utasítás, például:

<pre>
namespace&nbsp;aa.bb.cc

</pre>
aminek hatására a modulban definiált összes függvény
az <tt>aa.bb.cc</tt> (többszintű) névtérbe kerül.
A <tt>namespace</tt> utasítás nélkül, egyedileg is névtérbe 
helyezhetünk függvénydefiníciókat a következő módon:

<pre>
function&nbsp;&nbsp;aa.bb.cc.f()
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
A kétféle (globális és egyedi) minősítés (névtérbe helyezés) 
egyszerre is jelen lehet, ebben az esetben a hatásuk összegződik.
A modulon belül definiált függvények meghívásakor
nincs szükség teljes minősítésre.

<p>
A modul függvényeire (pl. <tt>f</tt>-re) kívülről a <em>minősített </em> névvel,
esetünkben az <tt>aa.bb.cc.f()</tt> formával hivatkozhatunk.
A kívülről történő hivatkozások megkönnyítésére szolgál a <tt>using</tt> utasítás.
A <tt>using</tt> utasítások a modul elején, közvetlenül az
esetleges <tt>namespace</tt> után állhatnak. A <tt>using</tt> olyan 
rövidítést vezet be, amivel elkerülhető a teljesen minősített 
függvénynevek túl sokszori kiírása.

<p>

<pre>
//&nbsp;alternatív&nbsp;using-ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;így&nbsp;hívjuk&nbsp;meg&nbsp;f-et

&nbsp;&nbsp;&nbsp;using&nbsp;aa.bb.cc=alias&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;alias.f()
&nbsp;&nbsp;&nbsp;using&nbsp;aa.bb=x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;x.cc.f()
&nbsp;&nbsp;&nbsp;using&nbsp;aa.bb.cc&nbsp;&nbsp;f&nbsp;g&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;f(),&nbsp;g()
&nbsp;&nbsp;&nbsp;using&nbsp;aa.bb&nbsp;&nbsp;cc.f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;cc.f()

</pre>

<p>
A globális (gyökér) névteret (kezdő) pont jelöli. 
Ha pl. a <tt>using&nbsp;aa.bb.cc&nbsp;&nbsp;f</tt> utasítás után 
<tt>aa.bb.cc.f</tt> helyett a globális névtérben definiált 
<tt>f</tt>-et akarjuk meghívni, akkor ezt kell irni: <tt>.f()</tt>.

<p>
A CCC névterek közvetlenül C++ névterekre vannak leképezve.

<p>
     <h3><a name="tth_sEc5.8.">
5.8</a>.&nbsp;&nbsp;Postfix függvényhívás</h3>

<p>
Nézzük ezt a kifejezést:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;padl(alltrim(str(round(x,2))),10,"0")

</pre>

<ul>
<li>    Az <tt>x</tt> változóban egy szám van,
<p>
</li>

<li>
    azt kerekítjük 2 tizedes jegyre,
<p>
</li>

<li>
    a számértéket karakter stringre konvertáljuk,
<p>
</li>

<li>
    levágjuk az elől/hátul esetleg  rajta levő szóközöket,
<p>
</li>

<li> 
    balról kiegészítjük "0" karakterekkel 10 szélességűre.
<p>
</li>
</ul>
Rengetegszer kell hasonló kifejezésekkel küszködni. 
Az a baj, hogy a sorozatosan egymásba ágyazott függvényhívásokat 
középről (az <tt>x</tt> változóból) kifelé haladva, hol balról, hol jobbról kell írni.
Egy ilyet visszafejteni végképp fárasztó.

<p>
Adódik a postfix függvényhívás ötlete. Értelmezzük a <tt>::</tt> (dupla kettőspont)
operátort a következőképp:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x::fuggveny1()&nbsp;&nbsp;//&nbsp;ua.&nbsp;mint&nbsp;fuggveny1(x)&nbsp;

</pre>
A postfix jelző arra utal, hogy a függvénynevet nem előre, hanem hátra, 
az első argumentum után írjuk. 

<p>
Nyilvánvaló, hogy a nyelv ,,tudása" nem változik a postfix függvényhívás
bevezetésével, csak a programírás kényelme növekszik. A hagyományos (prefix)
és a postfix függvényhívásból pontosan ugyanaz a kód generálódik.

<p>
Hogy igazán használható legyen, még egy-két általánosított formára szükség van.

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x::fuggveny1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;üres&nbsp;zárójelpár&nbsp;elhagyva
&nbsp;&nbsp;&nbsp;&nbsp;(x+y)::fuggveny1&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ua.&nbsp;mint&nbsp;fuggveny1(x+y)&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;x::fuggveny1(y,z)&nbsp;&nbsp;&nbsp;//&nbsp;ua.&nbsp;mint&nbsp;fuggveny1(x,y,z)&nbsp;

</pre>
Megállapodunk abban, hogy a <tt>::</tt> oprátor precedenciája magas, 
ugyanolyan, mint a metódushívás operátoré.

<p>
Az előző kifejezésünket most így írhatjuk.

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x::round(2)::str::alltrim::padl(10,"0")

</pre>

<p>
Itt akár meg is állhatnánk, ha nem ismernénk a <tt>+=</tt>, <tt>-=</tt> 
(hozzáadó, stb.) típusú operátorokat. Ezek mintájára kézenfekvő
bevezetni a <tt>::=</tt> operátort a következő értelmezéssel:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x::=fuggveny1()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ua.&nbsp;mint&nbsp;x:=fuggveny1(x)&nbsp;

</pre>
az összes variációjával együtt. Megállapodunk abban, hogy a <tt>::=</tt>
operátor precedenciája alacsony, ugyanolyan, mint a <tt>:=</tt>, <tt>+=</tt> 
(értékadás, stb.) operátoroké.

<p>
Ha egyszer van egy alacsony precedenciájú értékadó operátorunk,
felvetődik a kérdés,  van-e értelme zárójelezni a jobboldalon álló kifejezést.
Itt egy példa, ami mutatja, hogy van:

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;x:="1"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kiírja:&nbsp;1&nbsp;(karakter)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;x::=(val()+1)::str::alltrim&nbsp;&nbsp;&nbsp;//&nbsp;kiírja:&nbsp;2&nbsp;(karakter)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;x::=(val()+1)::str::alltrim&nbsp;&nbsp;&nbsp;//&nbsp;kiírja:&nbsp;3&nbsp;(karakter)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;x::=val+1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;kiírja:&nbsp;4&nbsp;(szám)

</pre>

<p>
Amikor a függvényhívás operátort (<tt>::=</tt> vagy <tt>::</tt>) 
nem egy egyszerű függvénynév követi, hanem egy zárójeles kifejezés,
azt még mindig értelmezhetjük függvényhívásnak, ha a zárójeles kifejezés
nyelvtani elemzőfájának bal szélén függvényhívás van. A gyakorlatban
ritkán fordul elő ez az eset, inkább csak azért foglalkozunk vele, 
hogy ne maradjon elvarratlan szál a nyelvtanban.

<p>
A nyelvtani elemző onnan ismer fel egy függvényhívást, hogy

<ul>
<li> egy szimbólumot zárójelpár között felsorolt (esetleg üres) 
       kifejezéslista követ (ez a hagyományos eset), vagy
<p>
</li>

<li>
      függvényhívás operátort egy szimbólum követ (postfix eset).
<p>
</li>
</ul>
Amikor a függvényhívás operátort nem közvetlenül követi a függvénynév
(mint ahogy a példában egy balzárójel ékelődik <tt>::=</tt> és <tt>val</tt> közé),
akkor az üres zárójelpárt nem lehet elhagyni.

<p>
 <h2><a name="tth_sEc6.">
6</a>.&nbsp;&nbsp;Objektumok</h2>

<p>
     <h3><a name="tth_sEc6.1.">
6.1</a>.&nbsp;&nbsp;Alapok</h3>

<p>
Az alábbi példában majdnem minden együtt van.

<pre>
class&nbsp;derived(base1,base2)

&nbsp;&nbsp;&nbsp;&nbsp;attrib&nbsp;&nbsp;a1
&nbsp;&nbsp;&nbsp;&nbsp;attrib&nbsp;&nbsp;a2

&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|this,p1,p2|expr(this,p1,p2)}
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;m2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|*|derived.m2(*)}
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;m3
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;m4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|this,*|this:a2:m(*[2..])}
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;m5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:a2:m

&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;initialize

static&nbsp;function&nbsp;derived.m2(this)
&nbsp;&nbsp;&nbsp;&nbsp;...

static&nbsp;function&nbsp;derived.m3(this,a,b,c)
&nbsp;&nbsp;&nbsp;&nbsp;...

static&nbsp;function&nbsp;derived.initialize(this,a,b,c)
&nbsp;&nbsp;&nbsp;&nbsp;this:(base1)initialize(a,b,c)
&nbsp;&nbsp;&nbsp;&nbsp;this:(base2)initialize(a,b,c)
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this&nbsp;&nbsp;//kötelező&nbsp;visszaadni&nbsp;a&nbsp;this-t

</pre>

<p>
A <tt>class</tt> kulcsszóval induló osztálydefiníciók a forrásban ugyanott állhatnak,
ahol a függvények. Az osztálydefiníció a következő <tt>class</tt>-ig, 
<tt>function</tt>-ig vagy a fájl végéig tart.

<p>
A példa egy <tt>derived</tt> nevű osztályt definiál, 
ami a <tt>base1</tt> és <tt>base2</tt> osztályokból van származtatva.
Mindig meg kell adni legalább egy alaposztályt, amiből az új osztály
örököl, ha mást nem, akkor a mindig létező <tt>object</tt> osztályt.

<p>
Az osztálydefiníció eredménye két függvény:
<tt>derivedClass()</tt> és <tt>derivedNew()</tt>,
általában az x nevű osztály esetén xClass és xNew.
A programban e két függvény képviseli az osztályt.

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;classid:=derivedClass()

</pre>
<tt>derivedClass()</tt> visszatérési értéke az osztályazonosító.
Maga az osztály a <tt>derivedClass()</tt> függvény első hívásakor jön létre.
A <tt>base1</tt> és <tt>base2</tt> osztályoknak is megvan a maguk class 
függvénye, amik <tt>derivedClass()</tt>-ból meghívódnak, és amik
szintén meghívják az ősosztályuk class függvényét, stb..

<p>
A <tt>derivedNew()</tt> függvénnyel példányosítjuk az osztályt. 

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;object:=derivedNew(p1,p2,p3)&nbsp;&nbsp;//derived&nbsp;osztályú&nbsp;objektum

</pre>
A <tt>derivedNew()</tt> előállít egy <tt>derived</tt> osztályú objektumot, 
amihez szüksége van a <tt>classid</tt>-re, meghívja tehát <tt>derivedClass()</tt>-t.
Ha még nem létezett, akkor ennek hatására minden szükséges osztály létrejön 
az <tt>object</tt> osztályig bezárólag.
A new függvény automatikusan végrehajtja az új objektum <tt>initialize</tt> 
metódusát, továbbadva neki minden paraméterét.

<p>
A <tt>derived</tt> osztály rendelkezik a
<tt>base1</tt> és <tt>base2</tt>-ből örökölt minden attribútummal és metódussal, 
plusz a <tt>derived</tt> osztályban definiált <tt>a1</tt>...,<tt>m1</tt>...  
attribútumokkal és metódusokkal.

<p>
A objektum felhasználója így hivatkozhat az attribútumokra és metódusokra:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;object:a1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;attribútum&nbsp;kiolvasás
&nbsp;&nbsp;&nbsp;&nbsp;object:a1:=x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;attribútum&nbsp;értékadás
&nbsp;&nbsp;&nbsp;&nbsp;object:a1++&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;értékadás&nbsp;minden&nbsp;variációban
&nbsp;&nbsp;&nbsp;&nbsp;object:a1+=1
&nbsp;&nbsp;&nbsp;&nbsp;object:m1(x,y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;metódushívás

</pre>

<p>
A <tt>class</tt>-ban kizárólag attribútum és metódus definíciók állhatnak.
A sorrendjük lényegtelen.

<p>
Az attribútumoknak egyszerűen megadjuk a nevét az <tt>attrib</tt> kulcsszó után. 

<p>
A <tt>method</tt> utasítások ennél bonyolultabbak.
Alapesetben a metódus neve után egy kódblokk van,
ez a kódblokk jelenti a metódus implementációját.
A metódushívás a kódblokk kiértékelésével történik.
Nézzük részleteiben. 
A rendszer megállapítja, hogy <tt>object</tt> osztálya <tt>derived</tt>.
Az osztályok nyilvántartásából
előszedi a <tt>derived</tt> osztály <tt>m1</tt> metódusához rendelt
kódblokkot. Ezt kiértékeli úgy, hogy a blokk első (<tt>this</tt>) paraméterébe
helyettesítődik maga az objektum, a <tt>p1</tt>-be <tt>x</tt>, <tt>p2</tt>-be <tt>y</tt>.
A metódus visszatérési értéke a kódblokk utolsó kifejezésének -
esetünkben <tt>expr(this,p1,p2)</tt> - értéke. 

<p>
A példában szereplő
<tt>this</tt> nem kulcsszó, csak konvenció, akármilyen szimbólum megfelelne.
Szabály viszont, hogy mindig a kódblokk első paraméterébe kerül az 
objektum (this, self, ki hogyan szereti).

<p>
Aha, ezek szerint az <tt>m2</tt> metódus implementációja a <tt>derived.m2</tt> függvény.
A metódus kódblokkja minden paramétert továbbít a benne meghívott függvénynek,
és mint tudjuk, az első paraméter a <tt>this</tt>.

<p>
Az <tt>m3</tt> metódus sorában a kódblokk helyén semmi sincs. 
Ilyenkor a fordító úgy jár el, mint az előző esetben, odateszi (odaérti) az

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;{|*|osztalyneve.metodusneve(*)}

</pre>
default kódblokkot, ami minden paraméter továbbadásával meghívja
az osztály nevével minősített, a metódus nevével egyező nevű függvényt.

<p>
Ezt a függvényt valahol implementálnunk kell. 
Ha a függvényt <tt>static</tt>-nak definiáljuk, akkor az a modulon kívülről 
függvényhívással nem érhető el, csak az objektumon keresztül metódushívással. 
Ha a metódus implementációt (kényszerűségből) más modulba tesszük, akkor nem lehet 
<tt>static</tt>, de legalább a névtér csökkenti a véletlen névütközés lehetőségét.

<p>
A függvénynek mindig van legalább egy paramétere, hiszen az első helyen megkapja 
a <tt>this</tt>-t. Ezt ugyanúgy ki kell írni, mint minden más normális paramétert.
(Nincs olyan bosszantó kétértelműség, mint amit C++-ban a ki nem írt this okoz). 

<p>
Az <tt>m4</tt> metódus kódblokkja kicsit bonyolultabb.
Feltételezzük, hogy az objektum <tt>a2</tt> attribútuma egy beágyazott
objektumot tartalmaz, méghozzá olyat, aminek van <tt>m</tt> nevű metódusa.
A kódblokk az <tt>m4</tt> metódushívást (minden paraméter továbbadásával) 
továbbítja a beágyazott objektum <tt>m</tt> metódusának.
Ha nem érthető, akkor az olvasónak újra át kell néznie 
a változó számú paraméterrel történő függvényhívást.

<p>
Az <tt>m5</tt> megint új eset? Nem egészen. Ez csak az <tt>m4</tt> kódblokk 
rövidített írásmódja. A metódushívás-továbbítás olvashatóbb formája.

<p>
Az objektumokat általában inicializáljuk.
Egy tipikus lehetőséget mutat be a példában szereplő <tt>initialize</tt> metódus.
Mindez azonban nem szabály. Az alkalmazás konkrét körülményeiből adódik, 
hogy mikor milyen inicializálásra van szükség. A

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;this:(base1)initialize(a,b,c)

</pre>
sor a (<tt>derived</tt> osztályú) <tt>this</tt> objektumra meghívja
a <tt>base1</tt> osztályban definiált <tt>initialize</tt> metódust.
Ez általában lehetséges, hiszen a leszármazás miatt <tt>this</tt>
egyúttal <tt>base1</tt> osztályú is. A speciális jelölést nevezzük 
metódus cast-nak.

<p>
Az inicializátornak kötelezően vissza kell adnia az objektumot (a <tt>this</tt>-t).

<p>
Megjegyzendő, hogy minden objektumnak van <tt>initialize</tt> metódusa.
Ha a saját osztályában nincs definiálva, akkor örökli valamelyik
felmenőjétől, ha máshonnan nem, akkor az <tt>object</tt> osztálytól.
Az <tt>object</tt> osztály inicializátora egyébként nem csinál semmit,
minthogy az <tt>object</tt>-ben nincs definiálva egyetlen attribútum sem.

<p>
Álljunk meg ezen a ponton egy kis összegzésre. 
Azt szeretném hangsúlyozni, hogy az eddigiek nagyon egyszerűek,
mivel kevés szabály logikus alkalmazásából adódnak.
Hogyan definiálunk egy osztályt?

<ul>
<li>     Megadjuk az osztály nevét a <tt>class</tt> utasításban.
<p>
</li>

<li> 
    Ugyanitt felsoroljuk az ősosztályok nevét.
<p>
</li>

<li> 
    A <tt>attrib</tt> utasításokkal felsoroljuk az attribútumokat.
<p>
</li>

<li> 
    A <tt>method</tt> utasításokkal felsoroljuk a metódusokat.
<p>
</li>

<li> 
    Tipikus esetben a metódushoz nem mellékelünk kódblokkot,
    hanem a metódus implementációját egy <tt>osztalyneve.metodusneve()</tt>
    függvénybe helyezzük.
<p>
</li>

<li>
    A beágyazott objektumokat és a metódushívás-továbbítást
    a fordító egyszerűen és szemléletesen támogatja.
<p>
</li>

<li>
    Néha tényleg annyira egyszerű a metódus, 
    hogy az egész implementáció belefér egy kódblokkba.
    Ilyenkor valósul meg az alapeset.
<p>
</li>
</ul>
Nem ritka, hogy egy osztálydefiníció
az attribútumok és metódusok  puszta  felsorolásából áll.
Egyszerűbb már nem lehetne. 
Vannak azonban részletek, amik fölött eddig átsiklottunk,
ezeket vesszük sorra a következő pontokban.

<p>
     <h3><a name="tth_sEc6.2.">
6.2</a>.&nbsp;&nbsp;Öröklődési szabályok</h3>

<p>
Az öröklődés többszörös, C++ terminológiát használva: public, virtual.
Ez azt jelenti, hogy az öröklés elől nem lehet eldugni az 
attribútum/metódusokat, azaz mindig minden öröklődik (public).
A metódusok közül mindig az objektum tényleges osztályának megfelelő hívódik 
meg (virtual). Nincsenek olyan nyakatekert szabályok, mint a C++-ban vagy Jávában.

<p>
A rendszer minden osztály részére létrehoz egy hashtáblát,
amiben az attribútum/metódus név a kulcs, az érték pedig

<ul>
<li> attribútum esetén egy tömbindex
       (ezen a helyen található az attribútum értéke az objektum 
       tartalmát hordozó tömbszerű memóriaobjektumban),
<p>
</li>

<li> metódus esetén egy kódblokk.
<p>
</li>
</ul>
A rendszer a névhez (kulcshoz) rendelt érték típusából tudja,
hogy attribútumról vagy metódusról van-e szó.

<p>
A rendszer a kezdetben üres hashtáblát feltölti. 
Először balról jobbra haladva végigmegy az ősosztályokon,
és összegyűjti az ezekből örökölhető tagokat. Ha olyan névvel találkozik,
ami már korábban bekerült a hashbe, akkor azt kihagyja. Ebből adódnak
a következő szabályok:

<p>
Ha a <tt>derived</tt> osztály <tt>base1</tt>-ből és <tt>base2</tt>-ből is
örökölhetne egy tagot, akkor <tt>base1</tt>-ből örököl.

<p>
Ha <tt>base1</tt>-ben és <tt>base2</tt>-ben is van attribútum
ugyanazon a néven, akkor ezeknek egyetlen közös attribútum felel
meg <tt>derived</tt>-ben.

<p>
Ezután a rendszer berakja a hashbe a <tt>derived</tt>-ben definiált
attribútumokat/metódusokat, azaz a származtatott osztály új attribútumokkal
és metódusokkal bővül az ősosztályhoz képest.

<p>
Eközben is előfordul névegyezés, 
most azonban a rendszer mindig a felülírja a korábbi értéket. 
Ez megfelel annak az objektumorientált programozási eljárásnak,
miszerint a származtatott osztály felüldefiniálja az ősosztályoktól
örökölt metódusok egyikét-másikát.

<p>
Előfordulnak azonban olyan esetek is, amikor

<ul>
<li>     attribútum definiál felül attribútumot,
    hatástalan, az attribútum nem többszöröződik meg,
<p>
</li>

<li>
    attribútum definiál felül metódust,
    a metódus megszűnik, helyette új attribútum,
<p>
</li>

<li>
    metódus definiál felül attribútumot,
    attribútum megszűnik, helyette új metódus
    (az attribútumindexek újraszámolódnak).
<p>
</li>
</ul>

<p>
Ezeknek az öröklődési szabályoknak az az előnyük, hogy egyszerűek.
Vannak nyelvek, amik bonyolult szabályrendszerrel lekezelik a többszörös 
öröklődés minden konfliktusát. Ezekkel rejtvényszerűen bonyolult
programokat lehet írni. Más nyelvek - ettől visszariadva - 
inkább egyszeres öröklődésre szorítkoznak.
Vannak szerzők, akik szerint már az egyszeres öröklődés is túl bonyolult,
amit nem tanácsos programozók kezébe adni (Trey Nash, C# 2008).

<p>
A mi hozzáállásunk praktikus. Megmaradunk a többszörös öröklődésnél,
de nem bonyolítjuk túl a dolgokat. Ha a fenti szabályok nem megfelelőek
egy feladatban, akkor valószínűleg nem érdemes az öröklődéses
programozási modellt erőltetni. Ilyenkor célszerű lehet
beágyazott objektumokhoz és metódushívás-továbbításhoz folyamodni.

<p>
Végül mutatunk egy példát virtuális metódusvégrehajtásra.

<p>

<pre>
************************************************************
function&nbsp;main()
&nbsp;&nbsp;&nbsp;&nbsp;baseNew(12345):print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//kiírja:&nbsp;12345
&nbsp;&nbsp;&nbsp;&nbsp;derivedNew(12345):print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//kiírja:&nbsp;12,345.00

************************************************************
class&nbsp;base(object)
&nbsp;&nbsp;&nbsp;&nbsp;attrib&nbsp;&nbsp;number
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;initialize
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;print
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;format

static&nbsp;function&nbsp;base.initialize(this,x)
&nbsp;&nbsp;&nbsp;&nbsp;this:number:=x
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//kötelező

static&nbsp;function&nbsp;base.print(this)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;this:format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//hogyan&nbsp;formattál?

static&nbsp;function&nbsp;base.format(this)
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;str(this:number)

************************************************************
class&nbsp;derived(base)
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;initialize
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//felüldefiniálja

static&nbsp;function&nbsp;derived.initialize(this,x)
&nbsp;&nbsp;&nbsp;&nbsp;this:(base)initialize(x)
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//kötelező

static&nbsp;function&nbsp;derived.format(this)
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;transform(this:number,"999,999,999.99")

************************************************************

</pre>
A példában mindkét kiírás a <tt>base</tt>-ben definiált <tt>print</tt>
metódussal történik. A nagy kérdés, hogyan történik a formattálás.
A <tt>base</tt> osztályú objektum a <tt>base</tt>-beli metódussal, 
a <tt>derived</tt> osztályú objektum viszont a <tt>derived</tt>-ben 
definiált metódussal formázódik. Ha a <tt>base</tt> osztályt nem akarjuk
példányosítani, akkor a <tt>base.format</tt> metódusra egyáltalán nincs szükség.

<p>
     <h3><a name="tth_sEc6.3.">
6.3</a>.&nbsp;&nbsp;Attribútum/metódus invariancia</h3>

<p>
A fordító és a futtatórendszer szándékosan úgy van megírva,
hogy egy objektum felhasználójának ne kelljen feltétlenül tudni róla,
hogy metódushívással, attribútum kiolvasással, netán attribútum értékadással
van-e dolga.

<p>
Először is rögzítsük: Metódushíváskor ugyanolyan szabadságunk van 
a paraméterezésben (a paraméterek darabszámát és típusát illetően), mint 
a függvényhívásban. A hívó akárhány darab, akármilyen típusú paramétert küldhet. 
A hívott kód saját hatáskörben dönti el, hogy egy konkrét paraméteregyüttesre 
mit felel.

<p>
Metódushíváskor az üres zárójelpárt nem kell kiírni.

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;obj:meth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//nem&nbsp;kell&nbsp;kiírni&nbsp;a&nbsp;zárójelpárt
&nbsp;&nbsp;&nbsp;&nbsp;obj:meth()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//ugyanaz

</pre>
Ha nincs zárójelpár, akkor formailag nincs különbség
a metódushívás és az attribútum kiértékelés között. A ,,rendszer"
belül azért tudja, miről van szó. Honnan? Onnan, hogy attrubútum esetén
egy index (szám), metódus esetén viszont egy kódblokk kerül elő az
osztály hashtáblájából.

<p>
A dolog meg is fordítható.

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;obj:attr()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//odaírható&nbsp;a&nbsp;zárójelpár&nbsp;(érdektelen)
&nbsp;&nbsp;&nbsp;&nbsp;obj:attr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//ugyanaz

</pre>
Tehát attribútumokat is elláthatunk üres zárójelpárral, mintha ott sem lenne.
Természetesen a háttérben az áll, hogy
a paraméter nélküli metódushívásnak 
és az attribútum kiolvasásnak
ugyanaz a kódja  a CCC veremgépén.

<p>
Célszerű az invarianciát teljessé tenni, kiterjeszteni
az attribútum értékadásra.

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;obj:attr:=x
&nbsp;&nbsp;&nbsp;&nbsp;obj:attr(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//ugyanaz

&nbsp;&nbsp;&nbsp;&nbsp;obj:meth(x)
&nbsp;&nbsp;&nbsp;&nbsp;obj:meth:=x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//ugyanaz

</pre>
Azért előnyös ez, mert így az objektum belső implementációjában
váltani lehet attribútum és metódus között anélkül, hogy a kliens kódban
mindenhol cserélgetni kellene a zárójeles paraméterlistákat és értékadásokat.

<p>
Az invarianciát kifejező legáltalánosabb forma:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;obj:meth(x,y,...):=z&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;obj:meth(x,y,...,z)&nbsp;//ugyanaz

</pre>

<p>
     <h3><a name="tth_sEc6.4.">
6.4</a>.&nbsp;&nbsp;Metódus cast</h3>

<p>
A virtuális metódushívást bemutató példában láttuk, 
hogy alapesetben mindig az objektum tényleges osztályában definiált metódus
hívódik meg. Néha ehelyett valamelyik ősosztály metódusára volna szükség,
amit azonban ,,eltakar" a származtatott osztályban definiált azonos nevű
metódus. Ilyen esetben folyamodunk a metódus-cast-hoz.
A leggyakoribb példa, amikor az inicializátor végrehajtja
az ősosztály inicializátorát.

<pre>
static&nbsp;function&nbsp;derived.initialize(this,p1...)
&nbsp;&nbsp;&nbsp;&nbsp;this:(base)initialize(p1...)&nbsp;&nbsp;&nbsp;&nbsp;//a&nbsp;base&nbsp;osztály&nbsp;inicializátora
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this

</pre>
A <tt>(base)initialize</tt> jelölés mutatja, hogy a <tt>base</tt>-ből
kell venni a metódust, nem pedig az aktuális osztályból. 
Ha a <tt>(base)</tt> hiányozna, akkor végtelen rekurzió volna az eredmény.

<p>
További két formája van a metódus-cast-nak:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;obj:(super@clsname)method

</pre>
Ez a <tt>clsname</tt> nevű osztály (valamelyik) közvetlen ősosztályában
definiált metódust hívja meg. A <tt>super</tt> ebben a formában kulcsszó.

<p>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;obj:(parent@child)method

</pre>
Ez a <tt>parent</tt> nevű osztályban definiált metódust hívja meg,
feltéve, hogy a <tt>child</tt> nevű osztály közvetlenül <tt>parent</tt>-ből
származik. Ha nem, akkor runtime error keletkezik.

<p>
A metódus-cast koncepciója: Az adott objektumra meghívjuk valamelyik 
<em>ősosztály metódusát</em>. Az ettől eltérő használat hibákhoz vezet:

<p>
 A metódus-cast-ban ne adjunk meg olyan osztályt, 
 aminek nincs köze az objektumhoz. Ha a rendszer úgy találja, hogy
 az <tt>obj:(base)method</tt> kifejezésben <tt>base</tt> nem felmenője
 <tt>obj</tt> osztályának, akkor runtime errort generál: 
 <tt>"prohibited&nbsp;method&nbsp;cast"</tt>.

<p>
 Ne alkalmazzunk metódus-cast-ot attribútumokra. 
 Sok tekintetben a metódusok és attribútumok
 egyformán viselkednek, ez azonban egy kivétel.
 Ha az <tt>obj:(base)method</tt> kifejezés kiértékelésekor kiderül, 
 hogy <tt>base</tt>-ben <tt>method</tt> mégsem metódus, hanem attribútum, 
 akkor runtime errort kapunk: <tt>"prohibited&nbsp;attribute&nbsp;cast"</tt>.
 (Legalább nem engedi tovább. Ha a rendszer továbbengedné, akkor 
 a program a <tt>derived</tt>  osztályú objektum attribútumainak tömbjében 
 a <tt>base</tt>-beli indexszel akarná megcímezni a keresett elemet.
 Ez mutatja, hogy a logikánk nem terjeszthető ki attribútumokra,
 legalábbis nem egyszerűen.)

<p>
     <h3><a name="tth_sEc6.5.">
6.5</a>.&nbsp;&nbsp;Láthatóság</h3>

<p>
      <h4><a name="tth_sEc6.5.1.">
6.5.1</a>.&nbsp;&nbsp;Static osztályok</h4>
A függvényekhez hasonlóan az osztályokat is definiálhatjuk <tt>static</tt>-nak.

<pre>
static&nbsp;class&nbsp;derived(base)

</pre>
A nem <tt>static</tt> esethez képest az a különbség, hogy a definícióból
(belsőleg) generálódó két függvény most <tt>static</tt> lesz,

<pre>
static&nbsp;function&nbsp;derivedClass()
&nbsp;&nbsp;&nbsp;&nbsp;...
static&nbsp;function&nbsp;derivedNew()
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
így ezekre nem lehet kívülről (másik modulból) hivatkozni. 

<p>
A static osztályok azonban mégsincsenek teljesen eltemetve.
A <tt>classidbyname()</tt> függvény neve alapján előkeresi az osztályazonosítót:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;classid:=classidbyname("derived")

</pre>
A ,,rendszer" semmire sem használja az osztályok nyilvántartásában
tárolt nevet. Az objektumrendszer működését ezért nem érinti, ha a nyilvántartásban
két különböző osztály esetleg azonos névvel szerepel. ,,Alkalmazások" azonban 
alapozhatnak a <tt>classidbyname()</tt> függvényre. Az ilyen alkalmazásoknál
ügyelni kell rá, hogy az osztálynevek ne ütközzenek. Különösen static
osztályoknál, ahol a linker nem figyelmeztet az ütközésre.

<p>
      <h4><a name="tth_sEc6.5.2.">
6.5.2</a>.&nbsp;&nbsp;Névterek és osztályok</h4>
Hogyan kombinálódnak a névterek és az osztálydefiníciók?
Az alábbi példa választ ad a kérdésre.

<pre>
namespace&nbsp;nsp

static&nbsp;class&nbsp;base(object)

class&nbsp;proba.szerencse.derived(nsp.base)
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;hopp

static&nbsp;function&nbsp;proba.szerencse.derived.hopp(this)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"HOPP"

</pre>
A <tt>namespace</tt> utasítás az egész modult az <tt>nsp</tt> névtérbe teszi.
A <tt>derived</tt> osztályban ez még tovább mélyül a <tt>proba.szerencse</tt> 
többszintű névtérrel.
Az ősosztály megadásakor ki kell írni a minősített osztálynevet: <tt>nsp.base</tt>.

<p>
Próbáljuk ki a programot az alábbi főprogrammal. A  <tt>namespace</tt> 
utasítás miatt ez most szükségszerűen külön modulban kell legyen, mert a <tt>main</tt>
nem lehet minősítve.

<pre>
function&nbsp;main()
local&nbsp;o
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"1.&nbsp;lista"
&nbsp;&nbsp;&nbsp;&nbsp;classListAll()
&nbsp;&nbsp;&nbsp;&nbsp;o:=nsp.proba.szerencse.derivedNew()
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"2.&nbsp;lista"
&nbsp;&nbsp;&nbsp;&nbsp;classListAll()
&nbsp;&nbsp;&nbsp;&nbsp;o:hopp
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;classidbyname("nsp.base")

</pre>
A program ezeket írja ki:

<pre>
1.&nbsp;lista

2.&nbsp;lista
&nbsp;&nbsp;&nbsp;1&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;14&nbsp;&nbsp;&nbsp;64
&nbsp;&nbsp;&nbsp;2&nbsp;nsp.base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;14&nbsp;&nbsp;&nbsp;64
&nbsp;&nbsp;&nbsp;3&nbsp;nsp.proba.szerencse.derived&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;64

HOPP
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2

</pre>
Az osztályok akkor jönnek létre, amikor a program hivatkozik rájuk.
Az 1. lista azért üres, mert a program nem csinált még egy objektumot sem.
A 2. lista tartalma:

<ol type="1">
<li> oszlop: osztályazonosító index (<tt>classidbyname("object")==1</tt>)
<p>
</li>

<li> oszlop: az osztály minősített neve
<p>
</li>

<li> oszlop: attribútumok száma
<p>
</li>

<li> oszlop: attribútumok+metódusok száma
<p>
</li>

<li> oszlop: hashtábla mérete
<p>
</li>
</ol>
A <tt>base</tt> osztályt hiába definiáltuk <tt>static</tt>-nak, 
mégis megjelenik a listában, és az azonosítója is megkapható (2).

<p>
      <h4><a name="tth_sEc6.5.3.">
6.5.3</a>.&nbsp;&nbsp;Hivatkozás a class függvényre</h4>

<p>
Mint látjuk, az xClass és xNew függvényekkel minden megeshet, 
ami a függvényekkel általában megesik. Névtérbe kerülhetnek, 
<tt>static</tt>-ok lehetnek.
Az xNew (objektumgyártó) függvénynél ennek következményei
nyilvánvalók, mert érvényesek rá a függvényekre vonatkozó 
általános szabályok.

<p>
Az xClass függvényt a programok általában nem használják közvetlenül. 
Az alábbi három szituációban azonban rejtve mégis a <tt>baseClass()</tt>
függvényre történik hivatkozás:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;1)&nbsp;class&nbsp;derived(base)
&nbsp;&nbsp;&nbsp;&nbsp;2)&nbsp;this:(base)initialize
&nbsp;&nbsp;&nbsp;&nbsp;3)&nbsp;recover&nbsp;err&nbsp;&lt;base&#62;

</pre>
Ha viszont így van, 
akkor itt is felvetődik a láthatóság és a névtér kérdése:

<p>
Ha a <tt>base</tt> osztály <tt>static</tt>-nak van definiálva,
akkor más modulból nem tudunk rá hivatkozni. Linkeléskor 
bukik ki az ilyen hiba, a linker nem találja a <tt>baseClass()</tt> függvényt.

<p>
Ha az alaposztály névtérből van, 
akkor azt teljes útvonallal jelölni kell:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;1)&nbsp;class&nbsp;derived(multi.level.namespace.base)
&nbsp;&nbsp;&nbsp;&nbsp;2)&nbsp;this:(multi.level.namespace.base)initialize
&nbsp;&nbsp;&nbsp;&nbsp;3)&nbsp;recover&nbsp;err&nbsp;&lt;multi.level.namespace.base&#62;

</pre>

<p>
     <h3><a name="tth_sEc6.6.">
6.6</a>.&nbsp;&nbsp;Defaulttól eltérő new függvény</h3>

<p>

<pre>
class&nbsp;derived(base)&nbsp;new:symbol
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>

<p>
A <tt>new:symbol</tt> toldalék opcionális. 
Ha hiányzik, akkor a default <tt>derivedNew</tt> 
nevű konstruktor készül.
Ha van new toldalék, de a symbol tagja üres 
(tehát ilyen alakú <tt>new:</tt>), akkor egyáltalán nem keletkezik 
konstruktor függvény. Teljes new toldalék esetén a 
<tt>symbol</tt>-ban megadott névvel képzett <tt>derivedSymbol</tt> 
konstruktort kapjuk.

<p>
     <h3><a name="tth_sEc6.7.">
6.7</a>.&nbsp;&nbsp;Metódushívás-továbbítás</h3>

<p>

<pre>
class&nbsp;proba(object)
&nbsp;&nbsp;&nbsp;&nbsp;attrib&nbsp;&nbsp;a1
&nbsp;&nbsp;&nbsp;&nbsp;attrib&nbsp;&nbsp;a2
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:a1
&nbsp;&nbsp;&nbsp;&nbsp;method&nbsp;&nbsp;m2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:a2:b:c:m

function&nbsp;main()
local&nbsp;p:=probaNew()
&nbsp;&nbsp;&nbsp;&nbsp;p:a1:="Próba&nbsp;szerencse"
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;p:m1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//kiírja:&nbsp;"Próba&nbsp;szerencse"

</pre>

<p>
A példában <tt>m1</tt> lényegében egy alias az <tt>a1</tt> attribútumra,
set-get metódusokat lehet így implementálni.

<p>
Az <tt>m2</tt> metódus feltételezi, hogy az <tt>a2</tt> (beágyazott objektum) 
attribútumnak, van egy <tt>b</tt> attribútuma, annak egy <tt>c</tt> attribútuma 
és annak egy <tt>m</tt> metódusa. Ennek a metódusnak továbbítódik a metódushívás.
Nem kell ismernünk <tt>m</tt> implementációját, automatikusan
minden paraméter továbbításra kerül. Ráadásul a fordító ügyesen
rendezgeti a stacket, nem jönnek létre felesleges függvényhívási szintek.

<p>
     <h3><a name="tth_sEc6.8.">
6.8</a>.&nbsp;&nbsp;A könyvtári object osztály</h3>

<p>

<pre>
class&nbsp;template(object)
&nbsp;&nbsp;&nbsp;&nbsp;attrib&nbsp;cargo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//teljesen&nbsp;üres&nbsp;is&nbsp;lehetne

function&nbsp;main()
&nbsp;&nbsp;&nbsp;&nbsp;templateNew():liststruct

</pre>

<p>
Az objektumorientált programozás erejét mutatja, 
hogy már az egyszerű <tt>template</tt> osztály is említésre 
méltó tudással rendelkezik, ugyanis egy csomó dolgot
örököl az <tt>object</tt>-től. Ki tudja listázni,
hogy milyen metódusai és attribútumai vannak, ki tudja listázni
az attribútumainak az értékét, meg tudja mondani az osztályának
és a szülő osztályainak a nevét. Ezzel a képességgel
<em>minden </em> osztály rendelkezik.  
Az <tt>object</tt>-ből öröklődő metódusokat vesszük most sorra.

<dl compact="compact">
 <dt><b>ancestors</b></dt>
	<dd>
  Ad egy listát az ősosztályok nevével.</dd>
 <dt><b>asarray</b></dt>
	<dd>
  Egy tömbben visszaadja az összes attribútumot.</dd>
 <dt><b>attrnames</b></dt>
	<dd>
  Ad egy listát az attribútumok nevével.</dd>
 <dt><b>attrvals</b></dt>
	<dd> 
  Visszad egy array-t, melynek elemei kételemű tömbök,
  az összes attribútum nevéből és értékéből képzett pár.</dd>
 <dt><b>baseid</b></dt>
	<dd>
  Ad agy arrayt, ami a közvetlen ősosztályok azonosítóit tartalmazza.</dd>
 <dt><b>classname</b></dt>
	<dd> 
  Visszaadja az objektum osztályának nevét.</dd>
 <dt><b>evalmethod</b></dt>
	<dd> 
  Név szerinti metódushívás (<tt>o:evalmethod("methname",{a,b,c})</tt>)</dd>
 <dt><b>initialize</b></dt>
	<dd>
  Inicializálja az objektumot.
  Valójában egy object osztályú objektumon nincs mit inicializálni,
  mert az osztályban nincs egyetlen attribútum sem, csak metódusok.</dd>
 <dt><b>isderivedfrom(clid/obj)</b></dt>
	<dd>
  Megmondja, hogy this (osztálya) leszármazottja-e az
  osztályazonosítóval/objektumpéldánnyal megadott másik osztálynak.</dd>
 <dt><b>length</b></dt>
	<dd>
  Megmondja az attribútumok számát.</dd>
 <dt><b>list</b></dt>
	<dd>
  Kilistázza magát (az attribútumait) a konzolra.</dd>
 <dt><b>liststruct</b></dt>
	<dd>
  Kilistázza, hogy milyen attribútumai, metódusai vannak,
  és melyiket honnan örökölte.</dd>
 <dt><b>methnames</b></dt>
	<dd>
  Ad egy listát a metódusok nevével.</dd>
 <dt><b>struct</b></dt>
	<dd>
  Ad egy tömböt, ami azt a struktúrát tartalmazza, amit liststruct
  kilistáz.</dd>
</dl>

<p>
Felsorolunk néhány további objektumokkal kapcsolatos
függvényt, amik azonban nem metódusai az object osztálynak:

<dl compact="compact">
 <dt><b>classListAll()</b></dt>
	<dd>
    Listázza a program összes osztályát.</dd>
 <dt><b>classIdByName(classname)</b></dt>
	<dd>
    Név alapján kikeresi és visszaadja az osztályazonosító számot.
    Ha a megadott névvel nincs osztály, akkor 0-t ad.</dd>
 <dt><b>getClassId(obj)</b></dt>
	<dd>
    Az objektumpéldányból megadja annak (szám) osztályazonosítóját.</dd>
 <dt><b>getObjectAsArray(obj)</b></dt>
	<dd>
    Egy tömbben visszaadja az összes attribútumot.
    Ezen a függvényen alapul az asarray metódus.</dd>
 <dt><b>iniObjectFromArray(obj,arr)</b></dt>
	<dd>
    Inicializálja az objektumot egy olyan arrayből,
    amit korábban a getobjectasarray (vagy asarray metódussal) 
    kaptunk, enélkül a getobjectasarray nem is volna értelmesen 
    használható.</dd>
 <dt><b>objectNew(clid)</b></dt>
	<dd>
    A függvény paramétere az osztályazonosító (szám).
    Visszaad egy megadott osztályú, új, inicializálatlan 
    objektumpéldányt. Ezen alapul minden konstruktor.</dd>
</dl>

<p>
A példaprogram a következőket írja ki:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;ancestors&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;asarray&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;attrnames&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;attrvals&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;baseid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;classname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;evalmethod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;initialize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;isderivedfrom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;liststruct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13&nbsp;methnames&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14&nbsp;struct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15&nbsp;cargo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;template

</pre>

<p>
     <h3><a name="tth_sEc6.9.">
6.9</a>.&nbsp;&nbsp;Függvény interfész</h3>

<p>
Többször volt már említve, hogy az osztálydefiníció eredménye
az xClass és xNew függvények. A programban ez a két függvény
képviseli az osztályt. Általában a fordítóprogram generálja ezeket
az osztálydefinícióból.

<p>
Talán nem meglepő, hogy ,,kézzel" is írhatunk xClass és xNew függvényeket.
Az alábbi példa létrehozza a <tt>template</tt> osztályt (kibővítve egy
<tt>initialize</tt> metódussal).

<p>

<pre>
static&nbsp;clid_template:=templateRegister()

static&nbsp;function&nbsp;templateRegister()
local&nbsp;clid:=classRegister("template",{objectClass()})
&nbsp;&nbsp;&nbsp;&nbsp;classMethod(clid,"initialize",{|this|template.initialize(this)})
&nbsp;&nbsp;&nbsp;&nbsp;classAttrib(clid,"cargo")
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;clid

static&nbsp;function&nbsp;template.initialize(this)
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this

function&nbsp;templateClass()
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;clid_template

function&nbsp;templateNew()
local&nbsp;clid:=templateClass()
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;objectNew(clid):initialize

</pre>

<p>
A <tt>classRegister</tt> függvény első argumentuma tartalmazza az új
osztály nevét, a második argumentum egy array, amiben az új osztály
szülő osztályait kell felsorolni. A legegyszerűbb esetben az új
osztály az objectClass-tól (minden osztály közös ősétől) származik.

<p>
A <tt>classMethod</tt> függvény egy metódust ad a clid-vel azonosított
osztályhoz. A metódus nevét a második paraméterben adjuk át, jelen 
esetben a név ,,initialize". A metódus végrehajtása a harmadik argumentumban 
átadott kódblokk kiértékelésével történik. A metódusblokkok első 
paramétere mindig maga az objektum, amit általában ,,this" névvel
illetünk, de itt ez nem kulcsszó, mint a C++-ban, vagy a Jávában.

<p>
A <tt>classAttrib</tt> függvény egy attribútumot ad a clid-vel azonosított
osztályhoz. 

<p>
Nyilvánvaló a megfelelés a <tt>class</tt> osztálydefiníció és a
függvényinterfész között. A fordítóprogram egyébként úgy működik,
hogy a <tt>class</tt> definícióból belsőleg előállítja a függvényinterfész 
kódot, és azt a szokásos módon lefordítja.

<p>
 <h2><a name="tth_sEc7.">
7</a>.&nbsp;&nbsp;Kivételkezelés</h2>

<p>
     <h3><a name="tth_sEc7.1.">
7.1</a>.&nbsp;&nbsp;Mikor kapunk el  kivételt?</h3>

<p>
Képzeljünk el egy tranzakció végrehajtó programot. 
Tegyük fel, hogy a tranzakció viszonylag bonyolult, 
sok külső feltételtől függ, végrehajtható-e.
Például egy betétlekötésnél kell legyen leköthető pénz,
kell legyen kamatláb, stb..
A program elkezdi a végrehajtást, ám egyszercsak kiderül,
hogy egy feltétel nem teljesül. Hiába minden erőlködés, 
nem lehet továbbmenni.

<p>
Mit csináljon a program? 

<p>
Egy lehetőség, hogy a függvény, ami észleli a hibát kiírja 
(csak a példa kedvéért) ,,nincs pénz", és kilép. 

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;nincs_penz&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"nincs&nbsp;pénz"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quit
&nbsp;&nbsp;&nbsp;&nbsp;end

</pre>
A legrosszabb. Tegyük fel, hogy egy ilyen programot kell javítanunk. 
Tudni akarjuk, hol nincs pénz, rákeresünk tehát a hiba szövegére,
és azt találjuk, a programozó következetes volt, a szöveg 10 helyen fordul 
elő a kódban. Rémálom.

<p>
Másik lehetőség, hogy a hibát észlelő függvény hibakóddal tér vissza. 
Ezzel sajnos nincs elintézve a dolog, mert bonyolult tranzakcióról lévén szó,
a kérdéses függvény akár 10-20 függvényhívási szint mélységben lehet. Tehát
a programot úgy kell megírni, hogy a hívó mindenhol felkészül a
hibakód ,,feljebb adására". Az ilyen program zavarossá válik,
eluralkodik benne a hibakezelés, megnehezül a karbantartás.

<p>
A kényes szituáció kezelésére szolgál (egy harmadik lehetőség) a kivétel dobás. 
A CCC-ben a

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;break(x)

</pre>
utasítással dobunk kivételt. Az <tt>x</tt> változó típusa bármi lehet.

<p>
Más nyelveknél (pl. Jáva) ezen a helyen a kivétel elkapásával folytatódna a leírás,
én szándékosan más sorrendet választok. Azt szeretném ezzel hangsúlyozni, hogy

<ul>
<li> a kivételnek nem az a célja és értelme, hogy elkapjuk, hanem
<p>
</li>

<li> a kivétel egyszerűen azt fejezi ki, hogy a program nem futhat tovább.
<p>
</li>
</ul>

<p>
Mire számíthatunk, ha nem kapunk el egy kivételt? Nézzünk egy példaprogramot:

<pre>
function&nbsp;main()
&nbsp;&nbsp;&nbsp;&nbsp;proba1()

function&nbsp;proba1()&nbsp;&nbsp;&nbsp;&nbsp;
local&nbsp;v:="x"
&nbsp;&nbsp;&nbsp;&nbsp;proba2()

function&nbsp;proba2()&nbsp;&nbsp;&nbsp;&nbsp;
local&nbsp;v:="y"
&nbsp;&nbsp;&nbsp;&nbsp;proba3()

function&nbsp;proba3()&nbsp;&nbsp;&nbsp;&nbsp;
local&nbsp;v:="z"
&nbsp;&nbsp;&nbsp;&nbsp;break("HOPP")

</pre>

<p>
A <tt>break("HOPP")</tt> hatására a program ,,elszáll" a következő hibaüzenettel:

<pre>
default&nbsp;error&nbsp;block&nbsp;evaluated
errorclass:&nbsp;C&nbsp;HOPP
&nbsp;&nbsp;called&nbsp;from&nbsp;deferror(215)
&nbsp;&nbsp;called&nbsp;from&nbsp;_blk__2(0)
&nbsp;&nbsp;called&nbsp;from&nbsp;proba3(14)
&nbsp;&nbsp;called&nbsp;from&nbsp;proba2(10)
&nbsp;&nbsp;called&nbsp;from&nbsp;proba1(6)
&nbsp;&nbsp;called&nbsp;from&nbsp;main(2)
-----------------------------------------------------------
&nbsp;Variable&nbsp;Stack
-----------------------------------------------------------
0:&nbsp;BINARY&nbsp;length=24&nbsp;oref=b7949048&nbsp;"^^^^^^^^^^^^^^^^^^^^^^^^"
1:&nbsp;BLOCK&nbsp;oref=NULL
*****&nbsp;function&nbsp;main
*****&nbsp;function&nbsp;proba1
0:&nbsp;STRING&nbsp;length=1&nbsp;oref=b7949008&nbsp;"x"
*****&nbsp;function&nbsp;proba2
1:&nbsp;STRING&nbsp;length=1&nbsp;oref=b7949018&nbsp;"y"
*****&nbsp;function&nbsp;proba3
2:&nbsp;STRING&nbsp;length=1&nbsp;oref=b7949028&nbsp;"z"
3:&nbsp;STRING&nbsp;length=4&nbsp;oref=b7949038&nbsp;"HOPP"
*****&nbsp;function&nbsp;_blk__2
4:&nbsp;BLOCK&nbsp;oref=NULL
5:&nbsp;STRING&nbsp;length=4&nbsp;oref=b7949038&nbsp;"HOPP"
*****&nbsp;function&nbsp;deferror
6:&nbsp;STRING&nbsp;length=4&nbsp;oref=b7949038&nbsp;"HOPP"
7:&nbsp;FLAG&nbsp;.T.
8:&nbsp;NIL
9:&nbsp;STRING&nbsp;length=0&nbsp;oref=b7949078&nbsp;""
10:&nbsp;ARRAY&nbsp;length=0&nbsp;oref=b7949088
11:&nbsp;NIL
-----------------------------------------------------------

</pre>
Kiíródik a callstack, minden függvényhívási szinten feltüntetve 
az aktuális programsor száma.
Kiíródik az összes static változó (main fölött), 
majd a függvényhívási szintek megjelölésével az egész local stack.
A gyakorlott programozó számára ez az infó az esetek többségében elegendő
egy hiba azonosítására.

<p>
Térjünk vissza a tranzakcióhoz, próbálkozzunk ilyen hibakezeléssel:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;nincs_penz&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break("nincs&nbsp;pénz")&nbsp;//quit&nbsp;helyett
&nbsp;&nbsp;&nbsp;&nbsp;end

</pre>
Máris beljebb vagyunk.
Még mindig nem foglalkozunk a hiba elkapásával.
Azért vagyunk lényegesen beljebb, mert bár a program most sem fut tovább,
nem veszítjük el a hibára vonatkozó infót, mint a <tt>quit</tt> után.
A programozó a hibalista elemzéséből debugolás nélkül is látja, hol
nem volt pénz.

<p>
Tegyük fel, hogy a tranzakció a 4. függvényhívási szinten indul,
a <tt>break("nincs&nbsp;pénz")</tt> kivétel dobása a 10. függvényhívási szintről jön,
mi pedig éppen egy 7. szinten levő függvény kódjában kotorászunk.
Meghívni készülünk egy függvényt, amiről tudjuk, hogy 
<tt>break("nincs&nbsp;pénz")</tt> kivételt dobhat. Mit tegyünk, kapjuk-e el a kivételt?

<p>
A legnagyobb baklövés:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;begin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuggveny8()&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;break("nincs&nbsp;pénz")&nbsp;jöhet&nbsp;belőle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;recover&nbsp;hiba&nbsp;&lt;C&#62;&nbsp;&nbsp;&nbsp;//&nbsp;elkapja
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//elkaptam&nbsp;a&nbsp;kivételt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//mert&nbsp;lelkiismeretes&nbsp;munkaerő&nbsp;vagyok,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//és&nbsp;úgy&nbsp;tanították,&nbsp;hogy&nbsp;a&nbsp;hibákat&nbsp;le&nbsp;kell&nbsp;kezelni,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//csak&nbsp;azt&nbsp;tudnám,&nbsp;most&nbsp;mi&nbsp;a&nbsp;fenét&nbsp;kezdjek&nbsp;vele?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//ez&nbsp;a&nbsp;legrosszabb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;hiba&nbsp;//kiírja:&nbsp;nincs&nbsp;pénz
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quit
&nbsp;&nbsp;&nbsp;&nbsp;end

</pre>
A program idejekorán elkap egy kivételt, 
amivel nem tud mit kezdeni, és ezzel megsemmisíti a hiba eredeti környezetét.
Sajnos a Jáva nyelv erőteljesen tereli a programozót ebbe az irányba,
ráadásul a Jáva tankönyvek szinte kivétel nélkül a fenti értelemben
káros hibakezelést tanítják.

<p>
A helyes hozzáállás:

<ul>
<li>     Észlelésekor nem a hiba elnyomására kell törekedni, 
    hanem kivételt kell dobni (a program nem folytatódhat).
<p>
</li>

<li>
    Csak olyan kivételt szabad elkapni, 
        amivel direkt kezdeni akarunk valamit.
    Kevés olyan hely van a programban, 
        ahol a hiba orvosolható, következésképp 
            az esetek többségében az a jó, ha a kivételt nem kapjuk el.
    Ha a hibát idejekorán elkapjuk, azzal megakadályozzuk, 
        hogy a kivétel eljusson a hibakezelésre ténylegesen felkészített kódhoz.
    Mindezek miatt az alapállás, 
        hogy nem kapkodunk kivételek után,
          hanem engedjük a hibát eljutni a felsőbb szintekre.
<p>
</li>

<li>
   A <em>tranzakció logikájának megfelelő helyen </em> (ha egyáltalán)
   felkészülünk a kivétel kezelésére.
<p>
</li>
</ul>
Ha egy kivétel sehol sincs elkapva, az nem feltétlenül baj. 
A program kilép, és pontos infót ad a kilépés okáról. 
Az esetek többségében éppen erre van szükség.
Mindez azonban nem szabály, inkább <em>szempont</em>.

<p>
A tranzakció logikája mellett még egy gyakorlati szempontot
tudok ajánlani kivétel elkapás (elkapjam-nekapjam) kérdésében. 
Ne kapjunk el <em>programhibát</em>, vagyis olyan kivételt, 
amit inkább a program kijavításával kell megszüntetni.

<p>
A CCC kivételkezelése nagyon hasonlít a Jávához. CCC-ben azonban nincs
külön throwable osztály, bármit lehet dobni, és bármit el is lehet kapni.
Logikus, hogy így van, hiszen <tt>break()</tt> közönséges függvény, akármilyen
paraméterezéssel meg lehet hívni. Az meg végképp nem volna szép,
ha valamit dobni lehet, de elkapni nem.

<p>
Kialakult az a konvenció, hogy a programozási 
hibákból <tt>error</tt> osztályú kivétel objektum keletkezik, amiket nem kapunk el. 
Ahol felmerülhet, hogy hasznos a kivétel elkapása, ott az <tt>apperror</tt> osztályt
vagy annak leszármazottait dobjuk. 
Tehát valahogy így készül a kivétel:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;nincs_penz&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:=apperrorNew()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:description:="nincs&nbsp;pénz"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break(error)
&nbsp;&nbsp;&nbsp;&nbsp;end

</pre>
Ha differenciáltabb hibakezelésre van szükség,
akkor az alkalmazás definiál magának speciális <tt>apperror</tt> 
leszármazottakat.

<p>
Az alábbi vázlat mutatja, 
hogyan gondolom a kivételkezelést összehangolni a tranzakció logikájával:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;van_meg&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;begin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tranzakcio()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//sikerült
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commit()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recover&nbsp;error&nbsp;&lt;apperror&#62;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//nem&nbsp;sikerült
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rollback()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end
&nbsp;&nbsp;&nbsp;&nbsp;end

</pre>

<p>
     <h3><a name="tth_sEc7.2.">
7.2</a>.&nbsp;&nbsp;A begin...recover utasítás</h3>

<p>
A következő példán tanulmányozzuk a <tt>begin...recover</tt> utasítás
technikai részleteit. Tanulságos a program lefordítása és próbálgatása 
különféle variációkban.

<pre>
function&nbsp;main(x)
local&nbsp;e
&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;x==NIL&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//NIL
&nbsp;&nbsp;&nbsp;&nbsp;elseif(&nbsp;isdigit(x)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x:=val(x)
&nbsp;&nbsp;&nbsp;&nbsp;elseif(&nbsp;x=='e'&nbsp;&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x:=errorNew()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x:description:="próba"
&nbsp;&nbsp;&nbsp;&nbsp;elseif(&nbsp;x=='a'&nbsp;&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x:=apperrorNew()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x:description:="szerencse"
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//karakter
&nbsp;&nbsp;&nbsp;&nbsp;end
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;begin&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuggveny1(x)
&nbsp;&nbsp;&nbsp;&nbsp;recover&nbsp;e&nbsp;&lt;N&#62;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"szám",e
&nbsp;&nbsp;&nbsp;&nbsp;recover&nbsp;e&nbsp;&lt;error&#62;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"error",e:description
&nbsp;&nbsp;&nbsp;&nbsp;finally
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"finally-main"
&nbsp;&nbsp;&nbsp;&nbsp;end
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"OK"
&nbsp;&nbsp;&nbsp;&nbsp;?

function&nbsp;fuggveny1(x)&nbsp;&nbsp;&nbsp;&nbsp;
local&nbsp;e
&nbsp;&nbsp;&nbsp;&nbsp;begin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fuggveny2(x)&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;recover&nbsp;e&nbsp;&lt;apperror&#62;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"apperror",e:description
&nbsp;&nbsp;&nbsp;&nbsp;finally
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"finally-fuggveny1"
&nbsp;&nbsp;&nbsp;&nbsp;end

function&nbsp;fuggveny2(x)&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;//errorblock({||qout("ERROR")})&nbsp;//kikapcsolja&nbsp;a&nbsp;hibakezelést
&nbsp;&nbsp;&nbsp;&nbsp;break(x)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"break&nbsp;után"

</pre>

<p>
A program az <tt>x</tt> argumentumtól függően különféle típusú kivételt dob. 
A <tt>break(x)</tt>-ben <tt>x</tt> típusa bármi lehet, mi most csak néhány variációt 
nézünk a példa kedvéért (NIL, szám, error, apperror, karakter).

<p>
A <tt>break(x)</tt> megszakítja a végrehajtás normál sorrendjét,
a rendszer elkezdi keresni a kivételt elkapó <tt>recover</tt> utasítást.

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;recover&nbsp;e&nbsp;[type_expr]

</pre>
A <tt>recover</tt> kulcsszót egy változó majd egy opcionális típuskifejezés követi.
A <tt>recover</tt> akkor kapja el a <tt>break</tt>-kel dobott kivételt, ha a 
<tt>break</tt> paraméterének típusa megfelel a <tt>recover</tt>-beli típuskifejezésnek.
Mi állhat a típuskifejezés helyén?

<ul>
<li>     Üres. Az ilyen <tt>recover</tt> mindent elkap.
<p>
</li>

<li> 
    Tetszőleges kifejezés, ami az adott helyen kiértékelhető.
    A kifejezésnek csak a típusa számít, az értéke
    nem hozzáférhető (de mellékhatásai lehetnek).
    A kifejezés már a <tt>begin...recover</tt> elején kiértékelődik.
    A különböző <tt>recover</tt> kifejezések kiértékelésénék sorrendje
    nincs meghatározva. A <tt>recover</tt> akkor kapja el a kivételt,
    ha a típusok megegyeznek.
<p>
</li>

<li>
    <tt>&lt;U&gt;</tt>, 
    <tt>&lt;L&gt;</tt>,
    <tt>&lt;N&gt;</tt>,
    <tt>&lt;D&gt;</tt>,
    <tt>&lt;P&gt;</tt>,
    <tt>&lt;C&gt;</tt>,
    <tt>&lt;X&gt;</tt>,
    <tt>&lt;A&gt;</tt>,
    <tt>&lt;B&gt;</tt>,
    <tt>&lt;O&gt;</tt>, azaz a különféle típusok kódja hegyes zárójelek között.
    Például: <tt>&lt;C&gt;</tt> jelöli a karakter típust,  
    a <tt>&lt;C&gt;</tt> típusú <tt>recover</tt> elkapja a karakter kivételeket.
<p>
</li>

<li>
    <tt>&lt;osztaly&gt;</tt>, vagyis osztálynév hegyes zárójelek között. 
    Az ilyen <tt>recover</tt> azokat az objektum típusú kivételeket kapja el, 
    amiknek az osztálya megegyezik a <tt>recover</tt> osztályával, vagy 
    annak leszármazottja.
<p>
</li>
</ul>

<p>
A <tt>recover</tt> ,,elkapja" a kivételt: Azt jelenti, 
hogy visszaállítódik a stack,
a kivétel (<tt>break</tt> paramétere) behelyettesítődik a <tt>recover</tt>
változóba (a példában <tt>e</tt>-be), és a végrehajtás a <tt>recover</tt> utáni
sorral folytatódik. Végrehajtódik a <tt>recover</tt> ág, ami a következő 
<tt>recover</tt>-ig, vagy az opcionális <tt>finally</tt>-ig, 
vagy a <tt>begin...recover</tt>-t lezáró <tt>end</tt>-ig tart.
Ha van <tt>finally</tt> ág, akkor az is végrehajtódik.
A végrehajtás ezután az <tt>end</tt>-et követő soron folytatódik.

<p>
Hol és milyen sorrendben keresi a rendszer a kivételt elkapó
<tt>recovert</tt>? Először is teszünk egy észrevételt: 
A <tt>begin...recover</tt> utasítások egymásba lehetnek ágyazva. 
A keresés a <tt>break</tt>-et tartalmazó legbelső <tt>begin...recover</tt> 
utasításban kezdődik. (A példában a <tt>fuggveny1</tt>-beli a legbelső.)
Itt a rendszer felülről lefelé haladva keres a <tt>recover</tt>-ek között.
Az első illeszkedő típus nyer.

<p>
Ha nem talál, akkor - mint héjakon - belülről kifelé haladva keres a
többi <tt>begin...recover</tt>-ben. Például a szám típusú kivételt 
a <tt>main</tt>-beli első <tt>recover</tt> fogja elkapni.

<p>
Miután megvan a kivételt elkapó <tt>recover</tt>,
a rendszer megnézi, hogy mely <tt>begin...recover</tt> utasításokon (héjakon)
kellett átvágnia magát, és végrehajtja ezek esetleges <tt>finally</tt> ágait. 
A sorrend természetesen belülről kifelé. Ezután a végrehajtás a nyertes 
<tt>recover</tt> ágra kerül, a többit már ismerjük.

<p>
A <tt>begin...recover</tt> specialitása a többi vezérlési struktúrához képest,
hogy átlépi a függvényhatárokat. Éppen ez kell a tranzakció-orientált hibakezeléshez.

<p>
De miért mondtuk, hogy csak miután megvan a <tt>recover</tt>, azután hajtódnak 
végre az átlépett/elhagyott <tt>begin...recover</tt>-ek <tt>finally</tt> ágai?
Miért nem a keresés közben? Mert nem tudható előre, lesz-e egyáltalán megfelelő
<tt>recover</tt>. Ha semmi sem kapja el a kivételt, akkor a <tt>begin...recover</tt>-ek
mintha ott sem lennének, az eset a magában álló <tt>break</tt>-hez hasonlít.
Ilyenkor sehova sem tevődik át a vezérlés (következésképp a <tt>finally</tt> ágak
sem játszanak), hanem a hiba <em>eredeti környezetében </em> kiértékelődik
az <tt>errorblock</tt>. Az eredményt már láttuk.

<p>
Hátra van még néhány speciális eset:

<p>
Ha a <tt>begin...recover</tt>-t nem szakítja meg <tt>break</tt>,
akkor a végrehajtás átugorja a <tt>recover</tt> ágakat,
belemegy az esetleges <tt>finally</tt>-ba,
majd az <tt>end</tt> után folytatódik.

<p>
Lehetséges, hogy nincs egy <tt>recover</tt> ág sem:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;begin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;finally
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;end

</pre>
Az ilyen struktúra nem kap el semmit,
de végrehajtódik a <tt>finally</tt> ág, ha nincs kivétel, 
vagy ha van, de azt elkapja egy külső <tt>begin...recover</tt>.

<p>
Lehetséges, hogy nincs <tt>finally</tt> sem:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;begin
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;end

</pre>
Ez viszont egyenértékű azzal, mintha az <tt>end</tt> előtt állna
egy mindent elkapó (üres) <tt>recover</tt> ág.

<p>
A  <tt>begin...recover</tt>-ből szabad kiugrani 
<tt>return</tt>, <tt>loop</tt>, <tt>exit</tt> utasításokkal.
Ilyenkor végrehajtódnak az elhagyott <tt>begin...recover</tt>-ek <tt>finally</tt> ágai.

<p>
Kezdetleges formában már a régi Clippernek is volt <tt>begin...recover</tt> 
utasítása. A CCC ezt kiterjesztette, és teljessé tette.

<p>
     <h3><a name="tth_sEc7.3.">
7.3</a>.&nbsp;&nbsp;Az errorblock</h3>

<p>
Még egy eszköz áll a hibakezelés szolgálatában, 
ami  a régi Clipperben is megvolt, az errorblock.  
Volt ilyen mondásunk: Az el nem kapott kivétel hatására a program ,,elszáll".
Mit jelent ez részleteiben?

<p>
A <tt>break()</tt> próbál olyan <tt>recover</tt>-t keresni, 
ami elkapja a kivételt, ám lehet, hogy nincs ilyen. 
Mi mást tehetne ilyenkor, valahogy be kell fejezni a programot,
kiértékeli hát az errorblockot. Az erroblock egy kódblokk,
ami direkt arra szolgál, hogy ez hajtódjon végre kezeletlen hiba esetén.

<p>
Már láttuk hogyan működik a beépített hibakezelő:
Kiírja a callstacket, varstacket, majd kilépteti a programot.
A hibakezeleő blokkot azonban az alkalmazás a saját igényei szerint 
lecserélheti, láncba fűzheti.

<pre>
local&nbsp;defblk:=errorblock()
&nbsp;&nbsp;&nbsp;&nbsp;errorblock({|x|naplo(x),eval(defblk,x)})
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
Ez a program először lekérdezi a default hibakezelőt
az <tt>errorblock()</tt> függvény paraméter nélküli hívásával,
majd ugyanezzel  beállít egy új hibakezelő kódblokkot,
amiben először naplózza a hibát, majd végrehajtja az eredeti hibakezelést.
Csak a példa kedvéért.

<p>
A <tt>begin...recover</tt> és <tt>break</tt> működését tanulmányozhatjuk
kikapcsolt hibakezelés mellett, ha a <tt>fuggveny2</tt>-ben megszüntetjük
az <tt>errorblock()</tt> hívás kikommentezését.

<p>
 <h2><a name="tth_sEc8.">
8</a>.&nbsp;&nbsp;Többszálúság</h2>

<p>
     <h3><a name="tth_sEc8.1.">
8.1</a>.&nbsp;&nbsp;Pthread API</h3>

<p>
A CCC2-től kezdve van multithread támogatás.
Az alább felsorolt API áll rendelkezésre
szálak indítására és szinkronizálására:

<pre>
thread_create(codeblock,p1,...)&nbsp;--&#62;&nbsp;threadid
thread_self()&nbsp;--&#62;&nbsp;threadid&nbsp;
thread_detach(threadid)&nbsp;--&#62;&nbsp;status
thread_exit()&nbsp;--&#62;&nbsp;NIL
thread_join(threadid)&nbsp;--&#62;&nbsp;status
thread_mutex_init()&nbsp;--&#62;&nbsp;xMutex
thread_mutex_lock(xMutex)&nbsp;--&#62;&nbsp;status
thread_mutex_trylock(xMutex)&nbsp;--&#62;&nbsp;status&nbsp;
thread_mutex_unlock(xMutex)&nbsp;--&#62;&nbsp;status&nbsp;
thread_mutex_destroy(xMutex)&nbsp;--&#62;&nbsp;status&nbsp;
thread_cond_init()&nbsp;--&#62;&nbsp;xCond
thread_cond_signal(xCond)&nbsp;--&#62;&nbsp;status
thread_cond_wait(xCond,xMutex[,nMillis])&nbsp;--&#62;&nbsp;status&nbsp;
thread_cond_destroy(xCond)&nbsp;--&#62;&nbsp;status

</pre>

<p>
A CCC szintre kivezetett egyszerűsített pthread API CCC-ből ugyanúgy működik, 
mint C-ből. Nincs értelme most referenciaszerű leírást adni róla, mert több
ilyen található az interneten. 
<a href="http://cs.pub.ro/~apc/2003/resources/pthreads/uguide/document.htm">Itt van pl. egy a számos közül</a>.
A  man is használható a <em>pthread </em>  címszavaknál. 
Magam is a man oldalak alapján dolgozom, pl.

<pre>
man&nbsp;3&nbsp;pthread_cond_signal

</pre>
Linuxon nyilvánvaló megfelelés van a pthread könyvtár és a CCC között.
Windowson ugyanez az interfész vissza van vezetve Windows API-ra, 
nem különösebben bonyolult.

<p>
Új szálakat  kódblokk végrehajtással indítunk.
A <tt>thread_create(blk,p1,...)</tt> függvényt pontosan úgy kell meghívni, 
mint az <tt>eval()</tt>-t, a különbség, hogy <tt>thread_create()</tt> azonnal visszatér,
miközben az új szál futásnak indul.

<p>
A szálak ugyanabban a változótérben dolgoznak. A static változók (külsők és belsők) 
közösek, egy példányban léteznek. Minden szál külön local stackkel rendelkezik.
Bármelyik szálból kiindulhat a szemétgyűjtés.

<p>
     <h3><a name="tth_sEc8.2.">
8.2</a>.&nbsp;&nbsp;Egyszerű példa - mutex</h3>

<p>
Az alábbi példa elindít 5 darab szálat.
Minden szál ugyanazt csinálja: 100,000-szer hozzáad 1-et a <tt>sum</tt> változóhoz,
a helyes végösszeg tehát 500,000 volna. A program azonban szándékosan el van rontva,
ki van kommentezve a <tt>sum++</tt> sort védő mutex lock. 

<pre>
static&nbsp;mutex:=thread_mutex_init()
static&nbsp;sum:=0

function&nbsp;main()
local&nbsp;blk:={||addtosum()}
local&nbsp;tid:={},i

&nbsp;&nbsp;&nbsp;&nbsp;aadd(tid,thread_create(blk))&nbsp;&nbsp;&nbsp;&nbsp;//új&nbsp;szál,&nbsp;az&nbsp;azonosítót&nbsp;megőrzi
&nbsp;&nbsp;&nbsp;&nbsp;aadd(tid,thread_create(blk))
&nbsp;&nbsp;&nbsp;&nbsp;aadd(tid,thread_create(blk))
&nbsp;&nbsp;&nbsp;&nbsp;aadd(tid,thread_create(blk))
&nbsp;&nbsp;&nbsp;&nbsp;aadd(tid,thread_create(blk))
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i:=1&nbsp;to&nbsp;len(tid)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;i,&nbsp;tid[i]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread_join(tid[i])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//megvárja,&nbsp;hogy&nbsp;befejeződjön
&nbsp;&nbsp;&nbsp;&nbsp;next
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"végösszeg",sum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//a&nbsp;helyes&nbsp;eredmény&nbsp;500000
&nbsp;&nbsp;&nbsp;&nbsp;?
&nbsp;&nbsp;&nbsp;&nbsp;
function&nbsp;addtosum()
local&nbsp;i
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i:=1&nbsp;to&nbsp;100000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//thread_mutex_lock(mutex)&nbsp;&nbsp;//kellene!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum++
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//thread_mutex_unlock(mutex)
&nbsp;&nbsp;&nbsp;&nbsp;next

</pre>

<p>
A mutex (<em>mut </em>ually <em>ex </em>clusive) olyan dolog, 
amit lockolni (zárolni, megfogni) és unlockolni (elengedni) lehet.
A lényeg, hogy egyszerre legfeljebb egy szál foghatja a mutexet.
Amíg egy szál fogva tartja, 
addig a többi szálból meghívott <tt>thread_mutex_lock</tt> vár
a mutex felszabadulására.  A mutex mechanizmussal tehát biztosítani lehet,
hogy egy kódrész végrehajtásával egyszerre legfeljebb egy szál foglalkozzon.

<p>
Fontos észrevétel, hogy a <tt>sum++</tt> művelet végrehajtása nem atomi.
Atomi nagyjából azt jelenti, hogy felbonthatatlan egység. 32-bites processzoron
egy 32-bites mennyiség memóriából történő kiolvasása atomi. 2 darab
32-bites mennyiség kiolvasása már nem atomi. Lehet, hogy
közben a processzor más tevékenységre vált, pl. folytatja egy másik szál
végrehajtását. <tt>sum++</tt> ehhez képest a static változó értékét 
(eleve több mint 64 bit) átrakja a local stackre, hozzáad 1-et, 
majd az eredményt visszamásolja az eredeti helyre. Sokszorosan nem atomi.

<p>
A saját gépemen 250 ezer körüli véletlenszerű eredményt kapok.
Kikommentezett mutex lock/unlockkal a példaprogram azért működik rosszul, 
mert egyszerre több szál is kiolvashatja <tt>sum</tt>-ból <em>ugyanazt </em> 
a pillanatnyi értéket, és ilyenkor valamelyik szál növekménye elvész.

<p>
Vigyázzunk, hogy a mutexet ne lockoljuk ugyanabból a szálból
többszörösen, ui.

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;thread_mutex_lock(mutex)
&nbsp;&nbsp;&nbsp;&nbsp;thread_mutex_lock(mutex)&nbsp;&nbsp;//deadlock

</pre>
deadlockot eredményez.

<p>
Egy további észrevétel. 
A példa a mutexet külső static változóként deklarálja. 
Az világos, hogy static-nak kell lennie. Ha local volna, akkor minden szálnak 
külön példánya volna belőle, nem tudná kifejteni a működését. De lehetne-e
belső static <tt>addtosum</tt>-ban? Az a nehézség, hogy a static változók 
(elvileg csak egyszer futó) inicializálását is szinkronizálni kell.
Szinkronizáció híján előfordul, hogy az inicializátor néha mégis többször fut.
Éppen ezért a CCC a külső static változók inicializátorát mindig 
szinkronizálja, hogy legyen biztos kiindulópont. A belső static változók 
inicializátora nincs automatikus mutex védelem alatt (ritkán kell, viszont költséges).

<p>
     <h3><a name="tth_sEc8.3.">
8.3</a>.&nbsp;&nbsp;Egyszerű példa - cond</h3>

<p>
A következő program sok szálat hoz létre.
A szálak véletlen hosszú ideig, átlagosan 1 másodpercig élnek,
az egyszerre életben levő szálak száma <tt>level&lt;=MAXTHREAD</tt>.
A program folyamatosan listázza a létrejövő és megszűnő szálakat,
mindaddig, amíg ESC-et nem ütünk neki.
Végül megvárja az összes thread kilépését.

<p>

<pre>
#include&nbsp;"inkey.ch"

#define&nbsp;MAXTHREAD&nbsp;&nbsp;16

static&nbsp;mutex:=thread_mutex_init()
static&nbsp;cond:=thread_cond_init()
static&nbsp;level:=0
static&nbsp;count:=0

function&nbsp;main()
local&nbsp;th

&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;inkey(0.05)!=K_ESC&nbsp;&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;th:=thread_create({|x,r|dothread(x,r)},count,rand())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread_detach(th)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//A&nbsp;threadeket&nbsp;vagy&nbsp;el&nbsp;kell&nbsp;engedni&nbsp;(thread_detach)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//vagy&nbsp;meg&nbsp;kell&nbsp;várni&nbsp;(thread_join),&nbsp;máskülönben
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//elfogynak&nbsp;a&nbsp;létrehozható&nbsp;threadek&nbsp;(Linuxon&nbsp;kb.&nbsp;90).

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread_mutex_lock(mutex)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//A&nbsp;level&nbsp;változót&nbsp;a&nbsp;threadek&nbsp;módosítgatják,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//ezért&nbsp;csak&nbsp;mutex&nbsp;védelem&nbsp;alatt&nbsp;biztonságos&nbsp;a&nbsp;kiolvasása.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;padl(l2hex(th),8),&nbsp;count,&nbsp;level
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++level
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++count
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;level&#62;MAXTHREAD&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread_cond_wait(cond,mutex)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread_mutex_unlock(mutex)
&nbsp;&nbsp;&nbsp;&nbsp;end

&nbsp;&nbsp;&nbsp;&nbsp;thread_mutex_lock(mutex)
&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;level&#62;0&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread_cond_wait(cond,mutex)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"wait",level
&nbsp;&nbsp;&nbsp;&nbsp;end
&nbsp;&nbsp;&nbsp;&nbsp;thread_mutex_unlock(mutex)

static&nbsp;function&nbsp;dothread(x,r)
&nbsp;&nbsp;&nbsp;&nbsp;sleep(r*2000)&nbsp;&nbsp;//átlagosan&nbsp;1&nbsp;másodpercet&nbsp;vár
&nbsp;&nbsp;&nbsp;&nbsp;thread_mutex_lock(mutex)
&nbsp;&nbsp;&nbsp;&nbsp;--level
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;"quit",x,r
&nbsp;&nbsp;&nbsp;&nbsp;thread_cond_signal(cond)
&nbsp;&nbsp;&nbsp;&nbsp;thread_mutex_unlock(mutex)

</pre>

<p>
A példa fő tanulsága, 
hogyan várunk arra <tt>main</tt>-ben, hogy a <tt>level</tt> változó 
(a többi szál tevékenységének következtében)
lecsökkenjen egy kívánt értékre.
A program elején egy mutex és egy cond objektumot hoztunk létre.
Általában egy cond (<em>cond </em>ition) objektumot mindig egy mutexszel együtt használunk.

<p>
Az alábbi kódrészletben a <tt>thread_cond_wait(cond,mutex)</tt>
híváskor <tt>mutex</tt>-nek lockolva kell lennie. A <tt>thread_cond_wait</tt>
automatikusan elengedi a mutexet, és vár, amíg valamelyik másik száltól szignált
nem kap. A várakozás alatt a szál futása fel van függesztve, semennyi CPU időt 
nem fogyaszt. Miután megjött a szignál
<tt>thread_cond_wait</tt> újra megfogja <tt>mutex</tt>-et, majd visszatér.

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;thread_mutex_lock(mutex)
&nbsp;&nbsp;&nbsp;&nbsp;while(&nbsp;level&#62;0&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread_cond_wait(cond,mutex)
&nbsp;&nbsp;&nbsp;&nbsp;end
&nbsp;&nbsp;&nbsp;&nbsp;thread_mutex_unlock(mutex)

</pre>

<p>
Eközben a többi szál minden alkalommal, 
amikor a <tt>level</tt> változó csökken, szignált küld,
hogy a várakozó szál értesüljön az eseményről.

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;thread_mutex_lock(mutex)
&nbsp;&nbsp;&nbsp;&nbsp;--level
&nbsp;&nbsp;&nbsp;&nbsp;thread_cond_signal(cond)
&nbsp;&nbsp;&nbsp;&nbsp;thread_mutex_unlock(mutex)

</pre>
A <tt>thread_cond_signal(cond)</tt> hívás ,,szignált küld" a <tt>cond</tt>
objektumnak. Ha egyetlen szál sincs, amelyik éppen  <tt>cond</tt>-ban várakozna,
akkor a szignál hatástalan. Ha több szál is várakozik <tt>cond</tt>-ban,
akkor ezek közül az egyik továbbindul, de hogy melyik, az nincs meghatározva.

<p>
     <h3><a name="tth_sEc8.4.">
8.4</a>.&nbsp;&nbsp;Thread-local storage</h3>

<p>
Tudjuk, 
hogy a program static változói csak egy példányban léteznek,
és az az egy példány minden szálra közös. 
Ezzel szemben minden szálnak saját local stackje van, 
a stack változók ezért szálanként elkülönülnek.
De nem csupán szálanként.
A local változók csak egy-egy függvényen belül léteznek,
és minden függvényhívásban külön létrejönnek.
Hol tudunk akkor olyan adatot tárolni, ami szálanként egyedi,
de egy szálon belül közös.  Az ilyen adatok kezelésére szolgáló 
mechanizmust nevezik ,,thread-local storage"-nak.

<p>
CCC-ben a <tt>localstack</tt> függvénnyel lehet egyszerű TLS-t csinálni.
Nézzük az alábbi programot:

<pre>
function&nbsp;main(a,b,c)
local&nbsp;x:="x",&nbsp;y:="y"
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;localstack(1)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;localstack(2)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;localstack(3)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;localstack(4)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;localstack(5)

</pre>
Ha a programot így indítjuk

<pre>
proba.exe&nbsp;q&nbsp;w

</pre>
akkor ezt a kimenetet kapjuk:

<pre>
q
w
NIL
x
y

</pre>
Világos, hogy <tt>localstack(x)</tt> előveszi (akár egy tömbből) 
a local stack <tt>x</tt>-edik elemét. Kicsit vigyázni kell vele,
de általában tudható, van-e elég érték a stacken, a példaprogramban
biztosan megvan legalább 5 darab.

<p>
Egyszerű ötlet: A thread közösnek szánt adatait tegyük be
a local stack aljára. Tulajdonképpen egyetlen érték is elég,
hiszen lehet az egy  hashtábla (vagy array, vagy objektum), 
amiben aztán annyi további adatot tárolhatunk, amennyi kell, 
és akár név szerint is hivatkozhatunk rájuk.

<p>

<pre>
local&nbsp;blk:={|p1,p2|dothread(p1,p2)}&nbsp;
local&nbsp;a,b,c
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;thread_create(blk,a:=simplehashNew(),b,c)
&nbsp;&nbsp;&nbsp;&nbsp;...

</pre>
A szálban hívott <tt>localstack()</tt> értékei:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;localstack(1)&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;&nbsp;blk
&nbsp;&nbsp;&nbsp;&nbsp;localstack(2)&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;&nbsp;a
&nbsp;&nbsp;&nbsp;&nbsp;localstack(3)&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;&nbsp;b
&nbsp;&nbsp;&nbsp;&nbsp;localstack(4)&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;&nbsp;nem&nbsp;definiált&nbsp;(dothread-től&nbsp;függ)
&nbsp;&nbsp;&nbsp;&nbsp;localstack(5)&nbsp;&nbsp;//&nbsp;--&#62;&nbsp;&nbsp;nem&nbsp;definiált,&nbsp;stb.

</pre>
A kódblokkot és a blokknak átadott paramétereket lehet megkapni
a szálból bárhonnan, legfeljebb olyan számban,
ahány <tt>p1</tt>, <tt>p2</tt>... paramétere van a blokknak.
A példában <tt>localstack(2)</tt> egy szálanként egyedi, 
de szálon belül közös hashtáblát ad.

<p>
     <h3><a name="tth_sEc8.5.">
8.5</a>.&nbsp;&nbsp;Szálbiztonság</h3>

<p>
A szálbiztonság első kritériuma: biztonság a szemétgyűjtéssel szemben. 
Minden olyan pillanatban, amikor egy másik szálból szemétgyűjtés indulhat, 
a vermeken kell legyen minden élő változó, de nem lehet ott semmi más,
pl. keletkezőben vagy megszűnőben levő változók. Ha egy változó nincs
rajta a stacken, akkor a hozzá tartozó memóriaobjektumot kitakaríthatja
a szemétgyűjtés. A keletkezőben vagy megszűnőben levő változók érvénytelen
pointereket jelentenek, amik elrontják a szemétgyűjtésben levő gráfbejárást.
Ha nem használnak saját C kódot, akkor az alkalmazásoknak ezzel nem kell 
törődniük, mert ilyen hibát  akármilyen rossz alkalmazáslogika sem okozhat. 

<p>
A szálbiztonság második kritériuma: a static-ok szinkronizálása.
A szálak által közösen használt static változókat szinkronizálni 
kell akár C++, akár CCC szinten. A CCC alapkönyvtárakben levő néhány 
static változó szinkronizálva van, a saját static-jaikat viszont
az alkalmazásoknak maguknak kell szinkronizálni.

<p>
E kritériumok teljesítése csak a ccc3 és ccc3_ui_ könyvtáraknál kitűzött cél. 
Árnyaltan fogalmazva ,,kitűzött", nem pedig elért célról beszélünk.

<p>
Szálbiztos a karakteres fullscreen megjelenítő könyvtár (ccc3_uic),
ha csak egy szál foglalkozik a képernyővel.

<p>
Szálbiztos a Jáva terminál könyvtár, 
ha csak egy szál használja a terminált, a többi szál mással foglalkozik.

<p>
Szálbiztos az sql2 könyvtár, 
ha minden szál külön adatbáziskapcsolaton keresztül dolgozik.

<p>
A különféle interfészek szálbiztonsága attól függ,
hogy az adott könyvtár (amit az interfész közzétesz) szálbiztos-e.

<p>
A szálbiztonság ellenőrzésére nincs általános módszer.
Egy lehetőség a hibahalászat. Véletlenszerűen mindenfélét csináló programokat
hagyunk futni napokig, hetekig. Ha a program hibázik, akkor megpróbáljuk
behatárolni a hibát, ami egyáltalán nem könnyű feladat.
Képzeljünk el egy olyan hibát, ami egy folyamatosan futó tesztprogramot
átlagosan  hetente akaszt meg... Szerencsére ilyen eset már évek óta
nem volt. Mérget azonban nem lehet rá venni. 

<p>
 <h2><a name="tth_sEc9.">
9</a>.&nbsp;&nbsp;Unicode</h2>

<p>
     <h3><a name="tth_sEc9.1.">
9.1</a>.&nbsp;&nbsp;Unicode támogatás</h3>

<p>
A régi Clipperben és a CCC1-CCC2-ben nem volt megkülönböztetve
a tetszőleges (akár bináris) adatokat tartalmazó bájtsorozat
és a karaktersorozatot tartalmazó string. Az ilyen típust egységesen 
karakternek (stringnek) neveztük, a típus kódja  "C" volt.
Hasonló volt a helyzet a 2.3 előtti Pythonban is.

<p>
Az idők azonban változnak, igény támadt az egyidejűleg
többféle nyelven is értő programokra. Világossá vált, hogy
a többnyelvűség igényeit legjobban a Unicode elégíti ki,
továbbá, hogy a Unicode problémáit (az operációs
rendszerrel való kompatibilitást illetően) legjobban
az UTF-8 kódolás oldja meg. A Unicode/UTF-8 kódolás univerzálisan 
elfogadottá vált, az operációs rendszerek sorra áttértek a használatára.
A változást a CCC-vel is követnünk kellett.
A CCC3 fő újdonsága a Unicode támogatás.

<p>
Az XMLRPC esete mutatja, mennyire elkerülhetetlen a változás követése. 
Egy 1999-es XMLRPC leírás azt mondja, hogy a <tt>string</tt>
adattípusban bámilyen adatot küldhetünk (binárisat is),
csak arra kell ügyelnünk, hogy az XML formázásban szerepet
játszó karakterek/bájtok (<tt>&lt;</tt>, <tt>&amp;</tt>) megfelelően védve legyenek. 
A pár évvel ezelőtti XML tankönyvekben fel sem vetődik a kérdés:
Miből áll az XML dokumentum?

<ul>
<li> Bájtok sorozatából,
<p>
</li>

<li> vagy karakterek sorozatából?
<p>
</li>
</ul>
A mai XML szabvány szerint karakterekből.
Az XMLRPC string tehát nem tartalmazhat bináris adatot, 
mert akkor elbukik az XML elemzésen. Hogy mik a karakterek,
az sem triviális, pl. a 0x00-0x20 intervallumban csak a
TAB, CR, LF számít karakternek, és máshol is vannak érvénytelen
(nem karakter) kódok, amikre a mai XML elemzők kivételt dobnak.

<p>
A Unicode támogatás megvalósítására két út kínálkozott.
A Pythonban úgy jártak el, hogy bevezettek (mint új dimenziót) 
egy új típust, a Unicodeot, ami minden mást érintetlenül hagyott.
A kompatibilitás szempontjából ez tökéletes megoldás,
azonban semmivel nem visz közelebb a régebbi programok
Unicodeosításához.

<p>
A CCC-ben a Jáva mintáját követve radikálisabb utat választottunk.
Bevezettünk egy új típust a bájtsorozatok számára. Ezt bájtarraynek,
bájtsorozatnak, vagy bináris stringnek nevezzük, a típuskódja "X"
(sajnos a B betű már foglalt a kódblokkok számára). 
A binary string (X) átveszi a régi
(C) stringek szerepét, amikor azok bináris adatot tárolnának.
A bináris stringekre működnek a szokásos string kezelő függvények
és operátorok: 
<tt>at</tt>, 
<tt>rat</tt>, 
<tt>strtran</tt>, 
<tt>left</tt>, 
<tt>right</tt>, 
<tt>padr</tt>, 
<tt>padl</tt>, 
<tt>substr</tt>, 
<tt>+</tt>, 
<tt>==</tt>, 
<tt>$</tt>, 
stb.

<p>
A korábbi (C) stringek értelmezése megváltozott,
a CCC3-ban Unicode karaktersorozatot jelentenek.
Természetesen az ismert string függvények ezekre is működnek.
A két string fajtát azonban nem lehet keverni, azaz nincs
feltétlen, automatikus konverzió.
Érdemes tudni, hogy az egyes karakterek C szinten <tt>wchar_t</tt>
típusban tárolódnak, ami a mai C fordítókban 32 bites mennyiség.

<p>
Nagyon fontos megérteni a karakter string és a binary string
közötti kapcsolatot. A karakter string (Unicode vagy UCS kódok
sorozata) szöveget tud tárolni. Ha a szöveget binary stringbe 
akarom átírni, akkor előállítom a Unicode karakterek UTF-8
kódját (karakterenként a karaktertől függő hosszúságú bájtsorozat),
ezeket konkatenálom, az eredmény egy bájtsorozat, amit a 
szöveg UTF-8 kódolású bináris reprezentációjának nevezek.
Bármely szöveg (karakter string) ezen a módon infóveszteség
nélkül bináris stringre konvertálható, és a bináris reprezentációból
maradék nélkül visszanyerhető. Általában a szöveg UTF-8 reprezentációja
több bájt, mint ahány karakter van az eredeti szövegben.
Ennek oka, hogy pl. a magyar ékezetes betűk vagy a cirill
betűk UTF-8 kódja két bájt. Más karakterek még hosszabbak
lehetnek, a létező leghosszabb UTF-8 kód hat bájtos.

<p>
Ha a karakter string memóriabeli tárolását vizsgáljuk,
azt tapasztaljuk, hogy sok 0 értékű bájt van benne.
Nyilván, ui. az ASCII kódok a 0-127 intervallumba esnek,
azaz egy bájtot foglalnak el, a string azonban 32-bitet 
használ minden karakterhez. A Unicode karakter stringekre ezért
nem működnek a C könyvtár hagyományos string kezelő függvényei,
amik a 0 bájtot a string végének tekintik. Ugyanezért nem
célszerű egy Unicode stringet bájtonként kiírni egy fájlba,
vagy egy socketba. Ezzel szemben a string UTF-8 reprezentációja
rendelkezik azzal a tulajdonsággal, hogy csakis a 0 Unicodenak
felel meg benne 0 bájt. Az UTF-8 bináris string így alkalmas
arra, hogy a program ezzel a típussal adjon meg egy fájlspecifikációt
az OS számára, amire a Unicode string nem felelne meg.

<p>
E megfontolásokból adódik, hogy mikor melyik string 
fajtát érdemes/kell használni a programokban.
Alapszabály, hogy a program szövegeit karakter stringben
tároljuk, és ebben a formában manipuláljuk. 
Vannak persze esetek, amikor ettől el kell térnünk.

<ul>
<li>     A fájlokból, socketekből általában bájtokat lehet olvasni.
<p>
</li>

<li>
    Az operációs rendszer számára UTF-8 kódolással 
    (tehát bináris string formájában) kell megadni a 
    fájlspecifikációkat.
<p>
</li>
</ul>
A koncepció, hogy az alkalmazási programokban minél
kevesebbet kelljen váltogatni a bináris és karakter
reprezentáció között, ehelyett a CCC könyvtár függvényei
alkalmas helyen automatikusan elvégzik a konverziót.
A <tt>memoread</tt>-et pl. általában arra használjuk,
hogy egy szövegfájlt egy mozdulattal beemeljünk  egy karakterváltozóba.
Ezért a <tt>memoread</tt> automatikusan karakter stringre
konvertálja, amit olvas. Néha azonban más kell, pl. amikor
egy png képfájlt olvasunk be, ezért a <tt>memoread</tt>
kiegészült egy opcionális paraméterrel, amivel kikapcsolható
ez a konverzió. Ilyenkor a <tt>memoread</tt> eredménye nem 
karakter, hanem binary string.
Az <tt>fopen</tt> a filénevet UTF-8-ra konvertálva adja 
lejjebb a C szintnek. 
Azokon a helyeken, ahol a stringtípusok találkoznak,
az alkalmazásnak mindenképpen explicite kell konvertálnia, 
ezért a programok elkerülhetetlenül bonyolultabbak lesznek, 
mint a CCC2-ben voltak.

<p>
Megemlítendő, hogy a Unicode/UTF-8 kódolás a CCC3-ban kizárólagos.
Ezen azt értem, hogy nincs támogatás semmilyen más kódolásra,
pl. Latin-1-re. Ezek a (hagyományos) kódolások elavultak,
és rendkívül megbonyolódik az élet, ha különféle kódolásokat
kell egyszerre kezelni. Mindez azt jelenti, hogy a CCC3 használata 
során az ember szövegfájljai szépen átkonvertálódnak UTF-8-ra.
A jelen sorokat a CCC3-mal fordított (tehát Unicode-os) z editorral írom,
és a saját terminálomban az angol, magyar és orosz szöveget
egyformán helyesen látom (és tudom gépelni), mint ahogy helyesen
látszik a <span class="roman">T</span><sub><span class="roman">E</span></sub><span class="roman">X</span>&nbsp;kimentetén és a böngészőben is. Mindehhez
nincs szükség bütykölt fontokra és billentyű driverekre.
Vannak tehát előnyök, amik kárpótolnak a bonyodalmakért. 
Bízzunk benne, hogy az UTF-8 kódolás hosszabb nyugvópont lesz 
a gyorsan változó informatikában.

<p>
     <h3><a name="tth_sEc9.2.">
9.2</a>.&nbsp;&nbsp;További megfontolások, kompatibilitás</h3>

<p>
Azt szeretném itt leírni, 
miért úgy van a Unicode string használat a CCC3-ban, ahogy van,
és hogyan kell választani a karakter és bináris string között. 

<p>
A 2.4.x Python támogatja a Unicode/UTF-8 kódolást.
Próbáljuk ki ezt a Python programot:

<pre>
#!&nbsp;/usr/bin/env&nbsp;python
#&nbsp;_*_&nbsp;coding:&nbsp;UTF-8&nbsp;_*_

a="öt&nbsp;szép&nbsp;szűzlány&nbsp;őrült&nbsp;írót&nbsp;nyúz"&nbsp;&nbsp;&nbsp;#&nbsp;bájtsorozat
u=u"öt&nbsp;szép&nbsp;szűzlány&nbsp;őrült&nbsp;írót&nbsp;nyúz"&nbsp;&nbsp;#&nbsp;Unicode&nbsp;string

print&nbsp;
print&nbsp;a[0:1]
print&nbsp;a
print&nbsp;u[0:1]
print&nbsp;u

</pre>
Ha lefuttatjuk a programot, ezt a kimenetet kapjuk: 

<pre>
?
&nbsp;öt&nbsp;szép&nbsp;szűzlány&nbsp;őrült&nbsp;írót&nbsp;nyúz
ö&nbsp;
öt&nbsp;szép&nbsp;szűzlány&nbsp;őrült&nbsp;írót&nbsp;nyúz

</pre>
Az első '?' valójában egy érvénytelen UTF-8 kód, egy fél 'ö' betű!
Ebből következtetek az alábbiakra:
Az <tt>a</tt> változóban egy bájtsorozat van, ami UTF-8 kódolással
ábrázolja az "öt szép..." szöveget. Az <tt>u</tt> változóban egy
(Unicode) karaktersorozat van, ami ugyanazt a szöveget ábrázolja.
Amikor a stringek első elemét vesszük, akkor az első esetben
az első <em>bájtot </em> a második esetben az első <em>karaktert </em>
kapjuk. Mivel az 'ö' betű UTF-8 kódolásban 2 bájton tárolódik,
azért kapjuk a fél 'ö' betűt, ami érvénytelen kód lévén '?' formában
jelenik meg. 
Ugyanez a program CCC3-ban így néz ki:

<pre>
function&nbsp;main()
local&nbsp;a:=a"öt&nbsp;szép&nbsp;szűzlány&nbsp;őrült&nbsp;írót&nbsp;nyúz"&nbsp;//bájtsorozat
local&nbsp;u:="öt&nbsp;szép&nbsp;szűzlány&nbsp;őrült&nbsp;írót&nbsp;nyúz"&nbsp;&nbsp;//Unicode&nbsp;string
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;left(a,1)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;a
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;left(u,1)
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;u

</pre>
Itt nem a Unicode stringet jelöljük <tt>u"..."</tt>-val,
hanem fordítva, a bájtsorozatot kell megkülönböztetni <tt>a"..."</tt>-val.
Az eredmény egyébként ugyanaz. A Python és a CCC3 Unicode támogatása 
közötti  eltérés:

<p>
A Python a Unicode-dal új területet nyit, de nem lép be erre
az új területre. A programozóra bízza a Unicode stringek bejelölését.
A kompatibilitás szempontjából ez tökéletes megoldás, hiszen a
régi programokat egyáltalán nem érinti. Szerintem azonban döntő
hátrány, hogy nem segíti elő az UTF-8 kódolást. Ha pl. egy régi
Python programot Latin-1-ről átkonvertálunk UTF-8-ra,
szintaktikailag semmi sem változik, mégis elromlik a program,
mert mint láttuk, megjelennek a félbevágott UTF-8 kódok.
Az új programoknál a Unicode stringek használatát kellene
előnyben részesíteni, a Python megközelítésében mégis
ezekhez kell többet írni, mindig jelölgetni kell az
<tt>u"..."</tt> stringeket.

<p>
A CCC3 készítésekor először én is hetekig a Python útján haladtam,
de egyre kevésbé tetszett a dolog. Végül úgy döntöttem,
hogy áttérek a radikálisabb megvalósításra: Nem csak létrehozom
az új területet, hanem be is lépek rá, azaz a Unicode string
lesz a default. Ugyanez van a Jávában is. A string literálok
Unicode karaktersorozatot jelentenek, emellett használható a
bájtarray, amikor arra van szükség. Utólag biztos vagyok
abban, hogy a Jáva/CCC3 megoldás a jobb, így vannak a helyükön
a dolgok, bár elismerem, hogy ez csak egy szubjektív vélemény.

<p>
Még egy fontos kérdés van: Legyen-e feltétlen és automatikus
konverzió a karaktersorozat és a bájtsorozat között?
A Pythonban van. Azt írják, hogy a két típus találkozásánál
a bájtsorozat automatikusan a ,,pontosabb" Unicode sorozatra
konvertálódik. Úgy gondolják, hogy a Unicode 32-bites lévén
pontosabb, mint a 8-bites bájt. Ez azonban egy melléfogás.
Az UTF-8 kódolással információveszteség nélkül tárolható
bármely Unicode string, fordítva azonban nem.
Ha egy png formátumú képet tartalmazó bájtsorozatot
Unicode stringre konvertálunk, akkor kép elromlik!
Tehát a Unicode sorozat egyáltalán nem ,,pontosabb", 
mint a bájtsorozat, hanem fordítva, de hasznosabb azt gondolni, 
hogy más. Ezért a CCC3-ban nincs feltétlen típuskonverzió.

<p>
A tapasztalat azt mutatja, hogy az a jó, ha a program 
a lehető legszélesebb körben Unicode stringeket használ,
és csak akkor tér át bájtsorozatra, amikor tényleg
bináris adatokkal dolgozik. 

<p>
Amikor olvasunk egy fájlból, azt kell feltételeznünk, hogy
bájtokat kapunk. Még ha tudjuk is, hogy a fájl mit tartalmaz,
a POSIX API bájtok olvasásához ad eszközöket. 
Ezt a szituációt úgy jellemzem, hogy a kétféle típus találkozik,
és az alkalmazásnak kell eldönteni, hogy legyen-e konverzió,
vagy ne. Ilyen a CCC2-ben nem volt, tehát a CCC3 mindenképpen
bonyolultabb lesz, sajnos.

<p>
Emlékeztetek rá, hogy a szabvány szerint az XML nem bájtok
sorozatából, hanem karakterek sorozatából áll. Amikor a programok
XML dokumentumot cserélnek, akkor valahogy sorosítani kell
a dokumentumot, azaz a karaktereket bájtsorozatra kell
konvertálni, ehhez valamilyen kódolás kell. Az XML szabvány 
az UTF-8-at jelöli ki default kódolásnak. Ahogy a CCC3 használja 
a Unicode/UTF-8 kódolást, úgy minden magától a helyén van. 
A <tt>ccc3_jt</tt> könyvtár Unicode string formájában dolgozik az XML 
szöveggel, majd közvetlenül küldés előtt az <tt>str2bin</tt>-nel 
UTF-8-ra konvertálja. A Jáva XML elemzője a DOM felépítésekor
az UTF-8 kódolású dokumentumot Unicodera konvertálja, 
a DOM-ból már Unicode stringeket lehet kiolvasni.
Hasonló a helyzet a fordított irányban.
A <tt>ccc3_jt</tt> portolásához ezért lényegében semmit sem 
kellett csinálni.

<p>
A GTK mindig is UTF-8 kódolással dolgozott, azaz egy editbox
szövegét UTF-8 kódolással kell beállítani, és úgy lehet megkapni.
A CCC-GTK csatolóba be van építve, hogy paraméter átadás/átvételkor
automatikusan végezze a Unicode&lt;-&#62;UTF-8 konverziót.
A CCC3 program tehát kényelmesen dolgozhat a Unicode
stringekkel.

<p>
Vannak függvények, amik természetüknél fogva bináris
adatokkal dolgoznak, pl. 
<tt>base64_encode</tt>,
<tt>base64_decode</tt>, 
<tt>crypto_md5</tt>, 
<tt>crypto_sha1</tt>,
<tt>crypto_rand_bytes</tt>,
<tt>savescreen</tt>, stb..

<p>
A fentiek alapján világos, 
hogy a CCC3 nem tud kompatibilis lenni a korábbi verziókkal,
ezért a CCC3 nem tudja egyszerűen leváltani a CCC2-t. 
Képtelenség minden régi programot egyszerre ,,felhozni" az új verzióra, 
egyúttal mindent újratesztelni. Mégha ez lehetséges  volna,
az sem volna elegendő, ui. a  CCC3  kizárólag  Unicode/UTF-8
kódolással dolgozik. Ha egy bank adatai Latin-2 kódolásúak, nem valószínű, 
hogy a kedvünkért hajlandók mindent átkonvertálni UTF-8-ra.

<p>
Érdemes-e esetleg a CCC3-ba beépíteni más kódrendszerek támogatását?
A véleményem határozott nem. Az Unicode/UTF-8 ui. nem arra lett kitalálva,
hogy még eggyel több kódrendszer legyen, amik között ide-oda lehet
konvertálgatni. (Hogy ezzel is több legyen a különböző kódrendszerek
miatti szenvedés.) Az UTF-8 az az univerzális sín, aminek mindent el kell vinnie.

<p>
Az ellentmondó szempontok feloldása, hogy a CCC2-t és a CCC3-at
is fenn kell tartani, előreláthatóan még hosszú ideig. A kezelendő
adatok kódolása alapján kell választani egyiket vagy a másikat.
Természetesen új projektekhez UTF-8 kódolást és CCC3-at választunk.

<p>
     <h3><a name="tth_sEc9.3.">
9.3</a>.&nbsp;&nbsp;Karakter/binary string literálok</h3>

<p>
      <h4><a name="tth_sEc9.3.1.">
9.3.1</a>.&nbsp;&nbsp;Karakter string</h4>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x1:="Kázmér&nbsp;füstölgő&nbsp;fűnyírót&nbsp;húz."
&nbsp;&nbsp;&nbsp;&nbsp;x2:="Копирование&nbsp;и&nbsp;распространение"

</pre>
A fenti értékadások  szövegének
kötelezően UTF-8 kódolásúnak kell lennie, másképp fordítási hiba
keletkezik: <tt>INVALIDENCODING</tt>. Ebből adódóan nem nélkülözhető
az UTF-8/Unicode környezet.
A programokat UTF-8 editorral kell írni (pl. a z-vel),
a régi szövegeket át kell konvertálni. A fordító maga nem konvertál,
csak hibát jelez, ha rossz a kódolás. A fordító az UTF-8 kódolású
szövegből előállítja a Unicode karakterek sorozatát, és ez a sorozat 
(vagyis a C típusú string) lesz a változók új értéke.
C++ szinten a Unicode (UCS) karakterek <tt>wchar_t</tt> 
típusban tárolódnak, ami általában 32 bites. 

<p>
      <h4><a name="tth_sEc9.3.2.">
9.3.2</a>.&nbsp;&nbsp;Binary string</h4>

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;x:=a"öt&nbsp;szép&nbsp;szűzlány&nbsp;őrült&nbsp;írót&nbsp;nyúz"

</pre>
A fenti értékadás eredményeképpen <tt>x</tt> típusa binary string (X),
tartalma pedig a szöveget UTF-8 kódolással reprezentáló bájtsorozat.

<p>
     <h3><a name="tth_sEc9.4.">
9.4</a>.&nbsp;&nbsp;Karakter/binary string függvények</h3>

<p>
Új függvények:

<dl compact="compact">
 <dt><b><tt>bin(code)</tt></b></dt>
	<dd>
    A <tt>chr(code)</tt> bináris párja. Egy 0-255 közé eső
    kódból egy bájt hosszú bináris stringet készít.</dd>
 <dt><b><tt>arr2bin(a)</tt></b></dt>
	<dd>
    A korábbi <tt>_arr2chr</tt>-t pótolja. Most nyilván a karakter
    stringeket is sorosítani kell, az eredmény egy bináris string
    (bájtsorozat).</dd>
 <dt><b><tt>bin2arr(x)</tt></b></dt>
	<dd>
    <tt>arr2bin(a)</tt> inverze.</dd>
 <dt><b><tt>str2bin(c)</tt></b></dt>
	<dd>
    Előállítja a <tt>c</tt> karakter string UTF-8 kódolású bináris
    reprezentációját. Ebből információveszteség nélkül visszanyerhető
    az eredeti string. A bináris reprezentáció sok helyen helyettesítheti
    is <tt>c</tt>-t.</dd>
 <dt><b><tt>bin2str(x)</tt></b></dt>
	<dd>
    <tt>str2bin(c)</tt> inverze. Tudni kell azonban,  ha <tt>x</tt>
    nem érvényes UTF-8 kódolású szöveget tartalmaz, akkor információ
    vész el, pl. egy png képfájl elromlik.</dd>
 <dt><b><tt>split(v,sep)</tt></b></dt>
	<dd>
    Helyettesíti a megszűnt <tt>wordlist</tt>-et.
    Karakteres és bináris stringekre is működik.</dd>
</dl>

<p>
Módusult függvények.

<p>

<dl compact="compact">
 <dt><b><tt>chr(code)</tt></b></dt>
	<dd>
    Egy 32 bites UCS kódból egy egy karakter hosszú stringet készít.</dd>
 <dt><b><tt>asc(v)</tt></b></dt>
	<dd>
    Ha <tt>v</tt> karakter string, akkor az első karakter UCS kódját adja.
    Ha <tt>v</tt> bináris string, akkor az első bájt értékét adja.</dd>
 <dt><b><tt>left(v,n)</tt></b></dt>
	<dd>
    Ha <tt>v</tt> karakter string, akkor <tt>v</tt> első <tt>n</tt>
    karakteréből álló részstringet adja.
    Ha <tt>v</tt> bináris string, akkor <tt>v</tt> első <tt>n</tt>
    bájtjából álló bináris részstringet adja.
    Utóbbi esetben, ha <tt>v</tt> egy szöveg UTF-8 kódolású bináris 
    reprezentációja, akkor ez a tulajdonság elromolhat, amennyiben 
    a <tt>left</tt> elvág egy több bájtos UTF-8 kódot.</dd>
 <dt><b><tt>len(v)</tt></b></dt>
	<dd>
    Ha <tt>v</tt> karakter string, akkor a <tt>v</tt>-ben levő karakterek
    számát adja.
    Ha <tt>v</tt> bináris string, akkor a <tt>v</tt>-ben levő bájtok
    számát adja.</dd>
 <dt><b><tt>replicate(v,n)</tt></b></dt>
	<dd>
    A <tt>v</tt> változó karakter és bináris string is lehet,
    az eredmény ennek függvényében C vagy X típusú. A rekordbuffereket
    régen a <tt>space</tt> függvénnyel hoztuk létre. Mivel ennek
    az eredménye C típus, ez most általában nem jó, helyette
    ilyesmit írunk: <tt>replicate(x"20",n)</tt>.</dd>
 <dt><b><tt>fread(fd,@buf,n)</tt></b></dt>
	<dd>
    Az <tt>fread</tt> nem karaktereket, hanem bájtokat olvas,
    ezért <tt>buf</tt>-ot X típusúra <i>kell </i> inicializálni.</dd>
 <dt><b><tt>fwrite(fd,buf,n)</tt></b></dt>
	<dd>
    Az <tt>fwrite</tt> nem karaktereket, hanem bájtokat ír,
    ezért, ha C típusú <tt>buf</tt>-ot adunk meg neki, azt automatikusan
    átkonvertálja X típusra <tt>str2bin</tt>-nel.</dd>
 <dt><b><tt>convertfspec2nativeformat(f)</tt></b></dt>
	<dd>
    Az eredményét mindig átkonvertálja binárisra, ui.
    az operációs rendszernek UTF-8 kódolású fájlspecifikációkat
    lehet megadni.</dd>
 <dt><b><tt>hashcode(v)</tt></b></dt>
	<dd>
    Karakteres és bináris stringekre is működik.</dd>
 <dt><b><tt>isalpha(v)</tt></b></dt>
	<dd>
    Karakteres és bináris stringekre is működik.
    C szinten az <tt>iswalpha</tt>, illetve az <tt>isalpha</tt>
    hívódik meg. Karakter string esetén az ékezetes és cirill 
    betűkre is jó eredményt ad.</dd>
 <dt><b><tt>qout(c,...)</tt></b></dt>
	<dd>
    A karakter stringek kinyomtatás előtt automatikusan
    átkonvertálódnak UTF-8-ra (vagyis  binárisra), 
    ui. az operációs rendszerek ezt értik.</dd>
 <dt><b><tt>savescreen()</tt></b></dt>
	<dd>
    A képernyő bináris stringként mentődik, egy screen
    cella a korábbiaktól eltérően most 4 bájt, mert UCS
    kódokat kell tárolni. A függvénycsalád összes tagja
    ehhez alkalmazkodik.</dd>
 <dt><b><tt>upper(v)</tt></b></dt>
	<dd>
    Karakteres és bináris stringekre is működik.
    C szinten a <tt>towupper</tt>, illetve a <tt>toupper</tt>
    hívódik meg. Karakter string esetén az ékezetes és cirill 
    betűkre is jó eredményt ad.</dd>
 <dt><b><tt>val(x)</tt></b></dt>
	<dd>
    Karakteres és bináris stringekre is működik.</dd>
 <dt><b><tt>valtype(v)</tt></b></dt>
	<dd>
    Bináris stringre "X"-et ad.</dd>
 <dt><b><tt>like()</tt></b></dt>
	<dd>
    Karakteres és bináris stringekre is működik.</dd>
 <dt><b><tt>memoread(fspec [,binopt])</tt></b></dt>
	<dd>
    Ha a <tt>binopt</tt> empty, akkor <tt>bin2str</tt>-rel
    karakterre konvertálja a beolvasott fájl tartalmát.
    Ez csak akkor jó, ha a fájl UTF-8 kódolású szöveget tartalmaz.
    Ha egy png képfájlt akarunk beolvasni, akkor azt 
    <tt>binopt:=.t.</tt>-vel tesszük, az eredmény ilyenkor
    egy bináris string.</dd>
 <dt><b><tt>memowrit(fspec,v)</tt></b></dt>
	<dd>
    Ha <tt>v</tt> egy karakteres string, akkor azt kiírás
    előtt átkonvertálja binárisra.</dd>
 <dt><b><tt>inkey() </tt></b></dt>
	<dd>
    Az inkey kódok megváltoztak, lásd az <tt>inkey.ch</tt>-t.</dd>
</dl>

<p>
     <h3><a name="tth_sEc9.5.">
9.5</a>.&nbsp;&nbsp;Internacionalizálás</h3>

<p>
Internacionalizálásnak sok összetevője van, 
mi itt csak egy dologgal foglalkozunk: 
Hogyan lehet többnyelvű CCC programot írni, 
amiben a string konstansok egyszerűen cserélhetők különféle 
nyelvi változatokra. 
Egy működő példa található a $CCCDIR/tutor/nlstext directoryban, 
ezt a példát magyarázom el részletesen az alábbiakban.

<p>
Az nlstext.prg program:

<pre>
static&nbsp;x:=@"Some&nbsp;like&nbsp;it&nbsp;hot"

function&nbsp;main()
&nbsp;&nbsp;&nbsp;&nbsp;nls_load_translation("nlstext")
&nbsp;&nbsp;&nbsp;&nbsp;fun()
&nbsp;&nbsp;&nbsp;&nbsp;?

static&nbsp;function&nbsp;fun()
static&nbsp;y:=@'Gentlemen&nbsp;prefer&nbsp;blondes'
local&nbsp;z:=@"Star&nbsp;war"
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;x
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;y
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;z
&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;@"Matrix"
&nbsp;&nbsp;&nbsp;&nbsp;?

</pre>
Először is azokat a stringeket, amiket a program különböző 
nyelvű verzióiban fordításban akarunk látni, meg kell jelölnünk.
Erre szolgál a speciális <tt>@"..."</tt> szintaktika.
A programfordítás idejére beállítjuk az alábbi 
környezeti változót:

<pre>
export&nbsp;CCC_NLSTEXT_TAB=$(pwd)/nlstext.tran

</pre>
Ennek hatására a <tt>ppo2cpp</tt> fordító kigyűjti nekünk a 
kukaccal megjelölt stringeket egy szövegfájlba, 
esetünkben nlstext.tran-ba:

<pre>
"Some&nbsp;like&nbsp;it&nbsp;hot"&lt;&lt;""&nbsp;from&nbsp;&nbsp;./nlstext.prg&nbsp;&nbsp;(21)
"Gentlemen&nbsp;prefer&nbsp;blondes"&lt;&lt;""&nbsp;from&nbsp;&nbsp;./nlstext.prg&nbsp;&nbsp;(33)
"Star&nbsp;war"&lt;&lt;""&nbsp;from&nbsp;&nbsp;./nlstext.prg&nbsp;&nbsp;(34)
"Matrix"&lt;&lt;""&nbsp;from&nbsp;&nbsp;./nlstext.prg&nbsp;&nbsp;(39)

</pre>
Itt soronként egy stringet találunk. A sor a lefordítandó
stringgel kezdődik, utána jön egy <tt>&lt;&lt;</tt> jel, majd egy 
üres idézet, ahová a fordítást kell majd beírni.
Az eddigiek azt jelölik, hogy a bal oldali stringet 
helyettesíteni fogja a jobb oldalra írt fordítás.
A sor végén fel van tüntetve, hogy az adott string melyik
forrásfájl melyik sorából származik.  Természetesen,
ha a project sok forrásfájlból áll, akkor az egyes fájlokból
jövő járulék halmozódik, ezért egy nagyobb program esetén
ezres nagyságrendű sor lehet az eredmény.

<p>
Minden nyelvhez készítünk egy-egy directoryt, esetünkben 

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;translation/hu
&nbsp;&nbsp;&nbsp;&nbsp;translation/ru

</pre>
ezekbe átmásoljuk az nlstext.tran egy-egy példányát, 
ezeken fognak dolgozni a fordítók. A fordító munkájának
eredménye egy ilyen fájl:

<pre>
"Some&nbsp;like&nbsp;it&nbsp;hot"&lt;&lt;"Несколько&nbsp;мужчин&nbsp;любят&nbsp;горячо"&nbsp;from&nbsp;&nbsp;./proba.prg&nbsp;&nbsp;(21)
"Gentlemen&nbsp;prefer&nbsp;blondes"&lt;&lt;"Господа&nbsp;любят&nbsp;лучше&nbsp;блондинок"&nbsp;from&nbsp;./proba.prg&nbsp;(33)
"Star&nbsp;war"&lt;&lt;"Война&nbsp;эвёэд"&nbsp;from&nbsp;&nbsp;./proba.prg&nbsp;&nbsp;(34)

</pre>
Ebből a fájlból a <tt>tran2cpp</tt> utility  C++ forrást generál,
amit lefordítunk, és  dinamikus könyvtárat linkelünk belőle.
Elvégezzük ugyanezeket a műveleteket a magyar változatra is.
A dinamikus könyvtárak neve:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;translation/libnlstext.hu.so
&nbsp;&nbsp;&nbsp;&nbsp;translation/libnlstext.ru.so

</pre>
Természetesen ugyanez megy Windowson is, csak ott dll-eket kapunk.

<p>
Namost, ha az nlstext.exe programot egy ilyen scripttel indítjuk:

<pre>
#!/bin/bash
export&nbsp;CCC_LANG=ru
export&nbsp;LD_LIBRARY_PATH=./translation:$LD_LIBRARY_PATH
nlstext.exe

</pre>
akkor a program elején található

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;nls_load_translation("nlstext")

</pre>
függvényhívás (amiről eddig nem szóltunk) a <tt>CCC_LANG</tt>
változó értékéből és a paraméterként kapott "nlstext" szövegből
összerak egy könyvtárnevet, és a könyvtárat megpróbálja betölteni. 
Ha ez a betöltés sikeres, akkor a program a <tt>@"..."</tt> stringek
helyett azok fordításait fogja megjeleníteni. Ha a fordításkönyvtár
dinamikus betöltése nem sikeres, vagy a könyvtár nem tartalmaz fordítást
egyik vagy másik stringre, attól még  működni fog a program,
csak ekkor a fordítással nem rendelkező stringek eredeti szövege 
jelenik meg.

<p>
 <h2><a name="tth_sEcA.">
A</a>.&nbsp;&nbsp;Régebbi dokumentációk</h2>

<p>
Összegyűjtöttem és belinkeltem néhány régről meglevő dokumentációt.

<p>
     <h3><a name="tth_sEcA.1.">
A.1</a>.&nbsp;&nbsp;
<a href="http://ccc.comfirm.hu/pub/ng">Eredeti Clipper doksi</a>
</h3>

<p>
Még mindig használható az eredeti
<a href="http://ccc.comfirm.hu/pub/ng">
 Clipper 5.x dokumentációjának HTML</a> változata.
Persze tudni kell, mik az elavult, és a még mindig érvényes
szakaszok. 

<ul>
<li> <a href="http://ccc.comfirm.hu/pub/ng/Clipper-guide/ng3ca.html">Functions</a>
    
<p>
    A dBase adatbáziskezeléssel kapcsolatos függvények a CCC-ből hiányoznak.
    Pl. az <tt>asize()</tt> leírása érvényes, de <tt>dbdelete()</tt> nincs.
<p>
</li>

<li> <a href="http://ccc.comfirm.hu/pub/ng/Clipper-guide/ng6fdf7.html">Commands</a>
    
<p>
    A dBase adatbáziskezeléssel kapcsolatos parancsok a CCC-ből hiányoznak.
    Vannak:
    <tt>?</tt>, 
    <tt>??</tt>, 
    <tt>@...box</tt>, 
    <tt>@...clear</tt>, 
    <tt>@...get</tt>, 
    <tt>@...say</tt>, 
    <tt>copy&nbsp;file</tt>, 
    <tt>erase</tt>, 
    <tt>keyboard</tt>, 
    <tt>quit</tt>, 
    <tt>rename</tt>, 
    <tt>run</tt>, 
    <tt>set...</tt>, és talán még egyebek is, nem emlékszem mindenre.
<p>
</li>

<li> <a href="http://ccc.comfirm.hu/pub/ng/Clipper-guide/ngb495e.html">Classes</a>
    
<p>
    A régi Clipperben csak ez a négy előre beépített objektum létezett,
    ezek a CCC-ben is megvannak. A CCC egyik nagy vívmánya, hogy komplett 
    objektumrendszer került bele.
<p>
</li>

<li> <a href="http://ccc.comfirm.hu/pub/ng/Clipper-guide/ngb4a83.html">Statements</a>
    
<p>
    Vannak:
    <tt>begin&nbsp;sequence</tt>,
    <tt>do&nbsp;case</tt>,
    <tt>do&nbsp;while</tt>,
    <tt>for</tt>,
    <tt>function</tt>,
    <tt>if</tt>,
    <tt>local</tt>,
    <tt>static</tt>,
    <tt>return</tt>.
    Innen meg lehet tanulni, hogyen kell <tt>if</tt> szerkezetet 
    vagy <tt>for</tt> ciklust írni. A <tt>begin&nbsp;[sequence]</tt> utasítás
    (vagyis a kivételkezelés) lényegesen bővült. A CCC-ben a Jávához
    hasonló kivételkezelés van.
<p>
</li>

<li> <a href="http://ccc.comfirm.hu/pub/ng/Clipper-guide/ngc8ba2.html">Operators</a>
    
<p>
    A <tt>&amp;</tt> (makró) és az <tt>=</tt> kivételével minden megvan a CCC-ben is.
<p>
</li>

<li> <a href="http://ccc.comfirm.hu/pub/ng/Clipper-guide/ngd8973.html">Directives</a>
    
<p>
    Az <tt>#error</tt> és <tt>#stdout</tt> kivételével minden.
<p>
</li>

<li> <a href="http://ccc.comfirm.hu/pub/ng/Clipper-guide/nge36fa.html">Get System</a>
    
<p>
    Ezek vannak:
    <tt>getactive()</tt>,
    <tt>getapplykey()</tt>,
    <tt>getpostvalidate()</tt>,
    <tt>getprevalidate()</tt>,
    <tt>getreader()</tt>.
<p>
</li>
</ul>

<p>
     <h3><a name="tth_sEcA.2.">
A.2</a>.&nbsp;&nbsp;
<a href="http://ccc.comfirm.hu/ccc3/build.html">CCC projekt manager</a>
</h3>

<p>
     <h3><a name="tth_sEcA.3.">
A.3</a>.&nbsp;&nbsp;
<a href="http://ccc.comfirm.hu/ccc3/jterminal.html">Jáva terminál</a>
</h3>

<p>
     <h3><a name="tth_sEcA.4.">
A.4</a>.&nbsp;&nbsp;
<a href="http://ccc.comfirm.hu/ccc3/sql2.html">SQL2 interfész</a>
</h3>

<p>
     <h3><a name="tth_sEcA.5.">
A.5</a>.&nbsp;&nbsp;
<a href="http://ccc.comfirm.hu/ccc3/cccgtk.html">GTK interfész</a>
</h3>

<p>


<hr>
Learn Hungarian in Budapest in <a href="http://ulysses.co.hu">Ulysses language school</a>.
Group and private <a href="http://www.ulysses.co.hu/courses_and_prices.php">courses</a> on affordable prices.
<hr>
</body>
</html>
